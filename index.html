<html>
    <head>
        <title>Clash Royale</title>
    </head>
    <body>
        <div align="center" style="margin: auto;"><canvas id="canvas"></canvas></div>
        <script src="https://www.tinkerdoodle.cc/static/jquery-3.5.1.min.js"></script>
        <script src="https://www.tinkerdoodle.cc/ka/processing-ka.js"></script>
        <script>
new Processing("canvas", proc => {
    with (proc) {
        size(600, 600);
        angleMode = "degrees";
/////////////////
/**
 * CLASH ROYALE
 * VERSION 1.1
 **/
//NOTICE: IF YOU MADE A SPIN-OFF, YOU MIGHT WANT TO REDO IT (I FIXED SOME MAJOR BUGS)
//NEVERMIND STILL FIXING BUGS
//Supercell logo
//Shop card stat bars
//Spell delay
//Wide bridge
/**
LATEST UPDATE INCLUDES:
 * MORE CARDS IN SHOP!
 * BETTER DECK SCROLL
 * SAVECODE IN GAME (PRESS S)
 * MORE LEVELS (14 NOW)
 * STARTING CARD LEVELS
 * COST FIXES
 * BETTER LEVEL MECHANICS
 * BETTER SPELLING AND CONVENTIONS
 * BETTER ORGANIZATION
 * LESS LAGGY ANIMATIONS (REMOVED)
 * BETTER GAME SPEED MECHANICS
 * FASTER GAME
 * LESS SCUFFED OPPONENTS
 * FIXED BRIDGE PLACEMENT!
 * GAME REWARD SCREEN
 * NUKERS CAN'T BE BOUGHT (EVER)
 * BETTER EMOTES!
 * PAUSE SCREEN!
 * DECK SAVES!
 * MORE CODES!
 * LESS CRAMPED TEXT!
 * BETTER TOWER GRAPHICS!
 * DELAYED PAUSE TIME!
 * BETTER BACKGROUND (I STOLE THE COLORS FROM CLASH ROYALE)
 * SLIGHTLY BETTER CHEST GRAPHIC!
 * BETTER BUTTONS AND COLORS
 * SPIRITS!
 * PULL (FISHERMAN AND TORNADO)!
 * KING TOWER ACTIVATION!
 * TOWER SEPARATION BUG FIXED!
 * SIGHT DISTANCE ADDED!
 * TIPS :)
 * ARENA GRAPHICS ADDED!
 * CARD OUTLINE CHANGES!
 * WORKING FAKE LEADERBOARD!
 * RANDOMNIZED DECK!
 * SLOWING CARDS!
 * SHOP REFRESH!
**/

//codes include: Starter, Dev, Infinite Money, Super Starter, Hardcore, Nukers, ThriftyPiano
//Case sensitive!
var code = 'Starter';
//wl, money, trophies, types array (what cards you unlocked)
/*
Savecode
*/
var savecode = [
    [0, 0], 0, 0, [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
    [4, 6, 11, 26, 50, 40, 28, 13]
];

//The code:
//{
if (code === 'Starter') {
    savecode = [
        [0, 0], 0, 0, [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
        [4, 6, 11, 26, 50, 40, 28, 13]
    ];
}
if (code === 'Dev') {
    savecode = [
        [0, 0], 1000000000, 1210, [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
        [4, 6, 11, 26, 50, 40, 28, 13]
    ];
}
if (code === 'Infinite Money') {
    savecode = [
        [0, 0], 1000000000, 0, [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
        [4, 6, 11, 26, 50, 40, 28, 13]
    ];
}
if (code === 'Super Starter') {
    savecode = [
        [0, 0], 10000, 0, [0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6],
        [4, 6, 11, 26, 50, 40, 28, 13]
    ];
}
if (code === 'Hardcore') {
    savecode = [
        [0, 0], 0, 1350, [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
        [4, 6, 11, 26, 50, 40, 28, 13]
    ];
}
if (code === 'Nukers') {
    savecode = [
        [0, 0], 0, 0, [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],
        [4, 6, 11, 26, 50, 40, 28, 13]
    ];
}
if (code === 'ThriftyPiano') {
    savecode = [
        [1, 0], 40, 26, [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
        [6, 50, 40, 28, 11, 13, 4, 26]
    ];
}

//makes it look good
smooth();
//HP, range, damage, reload, area of damage, speed, size, side, amt, name, cost, damage to tower, [air ground or tower, attacks air ground or tower], color, color, purchased?, type (color), description
var types = [
    [176, 20 * 5, 108, 102.8, 0, 120 / 100, 10, 3, "Spear goblins", 2, 108, [0, 1], color(0, 255, 0), color(150, 0, 0), 0, 0, "Goblins that throw spears"],
    [278, 20 * 2.5, 120, 60, 20 * 2.5, 120 / 100, 12, 1, "Electro spirit", 1, 120, [0, 1], color(85, 0, 204), color(51, 238, 255), 0, 0, "It's a shockingly good card"],
    [278, 20 * 2, 250, 60, 20 * 2.3, 120 / 100, 12, 1, "Fire spirit", 1, 250, [0, 1], color(48, 28, 16), color(247, 113, 64), 0, 0, "Don't get roasted"],
    [278, 20 * 2.5, 132, 60, 20 * 1.5, 120 / 100, 12, 1, "Ice spirit", 1, 132, [0, 1], color(222, 244, 247), color(41, 141, 255), 0, 0, "It's cold."],
    [403, 20 * 5, 142, 72, 0, 60 / 100, 12, 2, "Archers", 3, 142, [0, 1], color(255, 0, 255), color(200, 0, 0), 1, 0, "Girls with bows"],
    [108, 20 * 0.75, 108, 60, 0, 90 / 100, 8, 3, "Skeletons", 1, 108, [0, 0], color(255, 255, 255), color(200, 200, 200), 0, 0, "Skeletons with knives"],
    [2206, 20 * 1.2, 267, 72, 0, 60 / 100, 15, 1, "Knight", 3, 267, [0, 0], color(100, 100, 100), color(200, 200, 200), 1, 0, "Guy with sword"],
    [888, 20 * 0.7, 254, 84, 0, 60 / 100, 15, 5, "Barbarians", 5, 254, [0, 0], color(255, 230, 0), color(200, 200, 200), 0, 0, "Buff guys with swords"],
    [1186, 20 * 5.5, 281, 54, 0, 0 / 100, 20, 1, "Cannon", 3, 281, [-1, 0], color(150, 0, 0), color(0, 0, 0), 0, 0, "Its a cannon, ok?"],
    [268, 20 * 1, 159, 66, 0, 120 / 100, 8, 3, "Goblins", 2, 159, [0, 0], color(0, 255, 0), color(200, 200, 200), 0, 0, "Goblins with knives"],
    [440, 20 * 4.5, 294, 108, 20 * 1.5, 60 / 100, 12.5, 1, "Bomber", 2, 294, [0, 0], color(255, 255, 255), color(0, 0, 0), 0, 0, "Skeleton with bomb"],
    [0, 20 * 4, 486, 0, 20 * 4, 0 / 100, 20 * 4, 1, "Arrows", 3, 144, [1, 1], color(255, 0, 0), color(150, 150, 150, 0), 1, 0, "Rain of arrows"],
    [0, 20 * 2.5, 231, 0, 20 * 2.5, 0 / 100, 20 * 2.5, 1, "Giant snowball", 2, 70, [1, 1], color(255, 255, 255), color(150, 150, 150, 0), 1, 0, "Larger than your garden variety"],
    [305, 20 * 1, 135, 60, 0, 90 / 100, 12, 3, "Minions", 3, 135, [1, 1], color(0, 100, 200), color(0, 120, 240), 1, 0, "Blue flying guys"],
    [108, 20 * 1, 108, 78, 0, 120 / 100, 10, 5, "Bats", 2, 108, [1, 1], color(106, 0, 255), color(0, 0, 0, 0), 0, 0, "Purple flying guys"],
    [4068, 20 * 5, 406, 102, 0, 45 / 100, 25, 1, "Royal giant", 6, 406, [0, -1], color(255, 197, 125), color(0, 0, 0), 0, 0, "Giant with cannon"],
    [1776, 20 * 1, 508, 102, 0, 90 / 100, 15, 2, "Elite barbarians", 6, 508, [0, 0], color(255, 188, 107), color(179, 179, 179), 0, 0, "Super buff guys with swords"],
    [305, 20 * 1, 135, 60, 0, 90 / 100, 12, 6, "Minion horde", 5, 135, [1, 1], color(0, 100, 200), color(0, 120, 240), 0, 0, "Lots of blue flying guys"],
    [305, 20 * 6, 84 * 2, 60, 20 * 2.5, 90 / 100, 12.5, 1, "Firecracker", 3, 84 * 2, [0, 1], color(0, 50, 225), color(120, 0, 0), 0, 0, "Archer with fireworks"],
    [1023, 20 * 1.5, 176, 78, 0, 60 / 100, 15, 6, "Royal recruits", 7, 176, [0, 0], color(163, 125, 0), color(184, 184, 184), 0, 0, "People with spears they dont throw"],
    [0, 20 * 1, 254, 0, 20 * 1, 0 / 100, 20 * 2.5, 1, "Zap", 2, 76, [1, 1], color(0, 255, 255), color(0, 255, 255, 0), 0, 0, "Electricity coming from sky"],
    [1949, 20 * 11.5, 352, 300, 20 * 2, 0 / 100, 22.5, 1, "Mortar", 4, 352, [-1, 0], color(100, 100, 100), color(150, 150, 150), 0, 0, "Long range cannon launching rocks"],
    [1525, 20 * 5.5, 305, 72, 0, 0 / 100, 17.5, 1, "Tesla", 4, 305, [-1, 1], color(200, 200, 200), color(0, 200, 255), 0, 0, "Electricity cannon"],
    [705, 20 * 3.5, 213, 114, 20 * 0.8, 90 / 100, 17.5, 2, "Skeleton dragons", 4, 213, [1, 1], color(240, 240, 240), color(240, 240, 240), 0, 0, "Two skeleton dragons"],
    [0, 20 * 1, 1967, 0, 20 * 1, 0 / 100, 20 * 2, 1, "Rocket", 6, 591, [1, 1], color(70, 70, 70), color(140, 0, 0, 0), 0, 1, "Its a rocket"],
    [0, 20 * 3.5, 297, 0, 20 * 3.5, 0 / 100, 20 * 3.5, 1, "Earthquake", 3, 195, [1, 0], color(189, 157, 157), color(150, 150, 150, 0), 0, 1, "Don't fall through the cracks!"],
    [0, 20 * 1.5, 913, 0, 20 * 1.5, 0 / 100, 20 * 2.5, 1, "Fireball", 4, 274, [1, 1], color(255, 150, 0), color(0, 255, 255, 0), 1, 1, "A flaming ball"],
    [1587, 20 * 0.75, 112, 150, 0, 45 / 100, 15, 1, "Ice golem", 2, 112, [0, -1], color(150, 240, 255), color(255, 255, 255), 0, 1, "Frozen boxer"],
    [5423, 20 * 1.25, 337, 90, 0, 45 / 100, 25, 1, "Giant", 5, 337, [0, -1], color(160, 0, 0), color(160, 100, 0), 1, 1, "Large guy with fists"],
    [279, 20 * 2.5, 133, 60, 20 * 2, 120 / 100, 12, 1, "Heal spirit", 1, 133, [0, 1], color(255, 247, 0), color(255, 224, 51), 0, 1, "Heals your troops"],
    [702, 20 * 4.5, 154, 126, 0, 60 / 100, 15, 3, "Zappies", 4, 154, [0, 1], color(158, 132, 0), color(0, 247, 255), 0, 1, "Zappers"],
    [2248, 20 * 0.8, 421, 96, 0, 120 / 100, 17.5, 1, "Hog rider", 4, 421, [0, -1], color(160, 0, 0), color(200, 200, 200), 0, 1, "Pig with axe"],
    [2641, 20 * 1.2, 354, 90, 1.9 * 20, 60 / 100, 17.5, 1, "Valkyrie", 4, 354, [0, 0], color(209, 153, 0), color(200, 200, 200), 0, 1, "Girl with axe"],
    [1804, 20 * 1, 955, 96, 0, 90 / 100, 15, 1, "Mini pekka", 4, 955, [0, 0], color(0, 0, 0), color(0, 200, 255), 0, 1, "Robot with sword"],
    [1109, 20 * 1.5, 413, 96, 0, 60 / 100, 15, 1, "Mega minion", 3, 413, [1, 1], color(173, 173, 173), color(120, 136, 140), 0, 1, "Flying blue guy with armor"],
    [2073, 20 * 1.5, 179, 1.5 * 60, 4 * 20, 60 / 100, 15, 1, "Battle healer", 4, 179, [0, 0], color(255, 215, 0), color(200, 200, 200), 0, 1, "Cancer? Ice pack!"],
    [814, 20 * 6, 227, 66, 0, 90 / 100, 17.5, 1, "Flying machine", 4, 227, [1, 1], color(153, 89, 0), color(43, 43, 43), 0, 1, "Flying cannon"],
    [955, 20 * 5.5, 373, 84, 20 * 1.5, 60 / 100, 17.5, 1, "Wizard", 5, 373, [0, 1], color(0, 100, 255), color(200, 125, 0), 0, 1, "Guy who shoots flaming balls"],
    [1798, 20 * 6, 295, 96, 20 * 1.5, 0 / 100, 20, 1, "Bomb tower", 4, 295, [-1, 0], color(200, 125, 0), color(0, 0, 0), 0, 1, "Bomber in a tower"],
    [1109, 20 * 0.7, 98, 78, 0, 120 / 100, 15, 4, "Royal hogs", 5, 98, [0, -1], color(214, 157, 0), color(43, 43, 43, 0), 0, 1, "Pigs without axes"],
    [955, 20 * 6, 289, 60, 0, 60 / 100, 15, 1, "Musketeer", 4, 289, [0, 1], color(200, 0, 255), color(100, 100, 100), 1, 1, "Girl with musket"],
    [955, 20 * 6, 289, 60, 0, 60 / 100, 15, 3, "Three musketeers", 9, 289, [0, 1], color(200, 0, 255), color(100, 100, 100), 0, 1, "Three girls with muskets"],
    [345, 20 * 6.5, 174, 42, 0, 120 / 100, 10, 1, "Dart goblin", 3, 174, [0, 1], color(0, 255, 0), color(150, 0, 0), 0, 1, "Goblin with clarinet"],
    [108, 20 * 0.75, 108, 60, 0, 90 / 100, 10, 15, "Skeleton army", 3, 108, [0, 0], color(255, 255, 255), color(200, 200, 200), 0, 2, "Lots of skellies with knives"],
    [4452, 20 * 0.8 + 20, 354, 90, 0, 60 / 100, 20, 1, "Giant skeleton", 6, 354, [0, 0], color(255, 255, 255), color(200, 200, 200), 0, 2, "Big skeleton without knives"],
    [4982, 20 * 1.2, 1081, 108, 0, 45 / 100, 20, 1, "Pekka", 7, 1081, [0, 0], color(0, 0, 0), color(255, 0, 255), 0, 2, "Big robot with sword"],
    [0, 20 * 3, 138, 0, 20 * 3, 0 / 100, 20 * 3, 1, "Freeze", 4, 42, [1, 1], color(189, 252, 255), color(140, 0, 0, 0), 0, 2, "It's cold here"],
    [268, 20 * 1, 159, 66, 0, 120 / 100, 8, 3, "Goblin barrel", 3, 159, [0, 0], color(0, 255, 0), color(200, 200, 200), 0, 2, "Goblins in barrel"],
    [2226, 20 * 1, 848, 120, 0, 60 / 100, 17.5, 1, "Balloon", 5, 848, [1, -1], color(255, 0, 0), color(255, 0, 255, 0), 0, 2, "Bomber in balloon"],
    [0, 20 * 5.5, 204, 0, 20 * 5.5, 0 / 100, 20 * 5.5, 1, "Tornado", 3, 70, [1, 1], color(143, 143, 143), color(255, 0, 255, 0), 0, 2, "Whoosh"],
    [2544, 20 * 1.5, 519, 84, 0, 60 / 100, 17.5, 1, "Prince", 5, 519, [0, 0], color(255, 232, 99), color(0, 140, 171), 1, 2, "Guy with blue spear on horse"],
    [2008, 20 * 1, 328, 78, 20 * 1.1, 120 / 100, 17.5, 1, "Dark prince", 4, 328, [0, 0], color(99, 99, 99), color(43, 43, 43), 0, 2, "Guy with black club on horse"],
    [2120, 20 * 11.5, 55, 18, 0, 0 / 100, 25, 1, "X-bow", 6, 55, [-1, 0], color(100, 0, 0), color(150, 150, 150), 0, 2, "Arrow shooter"],
    [1110, 20 * 4, 2 * 112, 132, 3 * 20, 60 / 100, 15, 1, "Hunter", 4, 2 * 112, [0, 1], color(0, 9, 255), color(0, 0, 0), 0, 2, "Bullet shooter"],
    [1696, 20 * 4.5, 2 * 224, 144, 3 * 20, 60 / 100, 15, 1, "Executioner", 5, 2 * 224, [0, 1], color(0, 0, 0), color(176, 176, 176), 0, 2, "Guy throwing axe"],
    [2756, 20 * 4, 381, 150, 3.5 * 20, 45 / 100, 15, 1, "Bowler", 5, 381, [0, 0], color(111, 0, 255), color(173, 173, 173), 0, 2, "Guy bowling rocks"],
    [426, 20 * 1.5, 161, 60, 0, 90 / 100, 12.5, 3, "Guards", 3, 161, [0, 0], color(0, 0, 0), color(74, 74, 74), 0, 2, "Skeletons with spears and armor"],
    [1259, 20 * 3.5, 254, 126, 0, 60 / 100, 15, 1, "Electro dragon", 5, 254, [1, 1], color(0, 136, 255), color(0, 174, 255), 0, 2, "Dragon with electricity"],
    [1526, 20 * 3.5, 212, 90, 20 * 1.2, 90 / 100, 20, 1, "Baby dragon", 4, 212, [1, 1], color(0, 255, 100), color(0, 255, 100), 0, 2, "Baby dragon without electricity"],
    [345, 20 * 9, 224, 180, 20 * 2, 60 / 100, 12.5, 1, "Princess", 3, 224, [0, 1], color(255, 20, 200), color(0, 0, 0), 0, 3, "Girl with too many arrows"],
    [1696, 20 * 0.7, 320, 48, 0, 120 / 100, 15, 1, "Lumberjack", 4, 320, [0, 0], color(210, 180, 144), color(75, 75, 75), 0, 3, "Guy with axe"],
    [910, 20 * 5.5, 120, 102, 20 * 1, 60 / 100, 12.5, 1, "Ice wizard", 3, 120, [0, 1], color(0, 242, 255), color(5, 205, 255), 0, 3, "Guy shooting freezing balls"],
    [944, 20 * 5, 290, 108, 0, 90 / 100, 12.5, 1, "Electro wizard", 4, 290, [0, 1], color(0, 251, 255), color(3, 67, 242), 0, 3, "Guy shooting electro balls"],
    [5280, 20 * 0.5 + 20, 355, 102, 1.3 * 20, 60 / 100, 20, 1, "Mega knight", 7, 355, [0, 0], color(10, 10, 10), color(87, 87, 87), 0, 3, "Guy with metal fists"],
    [1152, 20 * 7 + 15, 256, 78, 0, 60 / 100, 15, 1, "Fisherman", 3, 256, [0, 0], color(255, 115, 0), color(10, 131, 245), 0, 3, "Guy with a fish"],
    [5040, 20 * 3.5, 72, 78, 0, 45 / 100, 15, 1, "Lava hound", 7, 72, [1, -1], color(99, 53, 0), color(255, 198, 105), 0, 3, "Beast shooting flaming balls"],
    [1600, 20 * 1, 345, 108, 20 * 1, 90 / 100, 15, 1, "Royal ghost", 3, 345, [0, 0], color(255, 255, 255, 100), color(200, 200, 200, 200), 0, 3, "Ghost with sword"],
    [1200, 20 * 0.75 + 15, 256, 60, 0, 90 / 100, 15, 1, "Bandit", 3, 256, [0, 0], color(0, 0, 0), color(189, 79, 0), 0, 3, "Girl with stick"],
    [1460, 20 * 1.2, 233, 60 * 1.2, 0, 90 / 100, 15, 1, "Miner", 3, 59, [0, 0], color(250, 220, 0), color(128, 128, 128), 0, 3, "There's no gold!"],
    [1920, 20 * 5, 1760, 240, 20 * 1.8, 45 / 100, 22.5, 1, "Sparky", 6, 1760, [0, 0], color(166, 166, 166), color(0, 227, 252), 0, 3, "Boom on wheels"],
    [1330, 20 * 5, 299, 72, 0, 60 / 100, 15, 1, "Archer queen", 5, 299, [0, 1], color(255, 0, 0), color(50, 50, 50), 0, 4, "Arrow shooter"],
    [3059, 20 * 1.2, 274, 96, 1.1 * 20, 60 / 100, 17.5, 1, "Skeleton king", 4, 274, [0, 0], color(255, 229, 112), color(143, 143, 143), 0, 4, "Giant skeleton with club"],
    [2661, 20 * 1.2, 212, 54, 0, 60 / 100, 15, 1, "Golden knight", 4, 212, [0, 0], color(252, 222, 86), color(191, 191, 191), 0, 4, "Vainglorious knight"],
    [2420, 20 * 1.2, 169, 48, 0, 60 / 100, 15, 1, "Monk", 5, 169, [0, 0], color(250, 179, 87), color(247, 237, 247), 0, 4, "Not a monkey!"],
    [10, 1, 0, 1000, 0, 120 / 100, 20, 1, "Tesla (car)", 10, 0, [0, 1], color(200, 200, 200), color(50, 50, 50, 0), 0, 5, "Its a car"],
    [6408, 7.5 * 20, 144, 1, 0, 0 / 100, 50, 4, "Nukers", 10, 144, [-1, 1], color(255, 255, 255), color(255, 255, 255), 0, 5, "Only for devs"],
    [3668, 7.5 * 20, 131, 48, 0, 0 / 100, 20, 1, "Princess tower", 11, 131, [-1, 1], color(255, 0, 255), color(0, 0, 0), 1, 5, "Its a tower"],
    [6408, 7.5 * 20, 144, 60, 0, 0 / 100, 20, 1, "King tower", 11, 144, [-1, 1], color(255, 0, 255), color(0, 0, 0), 1, 5, "Its a tower"],
];
//variables and stuff {
//set the types array to what the savecode is
for (var i = 0; i < types.length; i++) {
    types[i][14] = savecode[3][i];
}
var cardlevelmult = [0];
for (var i = 0; i < 14; i++) {
    cardlevelmult.push(pow(1 / 1.1, 13 - i));
}
//troops array
var troops = [];
//fake frameRate
var from = 1;
//in game?
var ingame = true;
var pausecounter = 0;
var pausetime = 20;
//trophies
var trophies = savecode[2];
var faketrophies = savecode[2];
//wins and losses
var wl = savecode[0];
//x, y, hp, maxhp, two arrays for sides
var towers = [
    [
        [300, 45, 6408, 6408],
        [180, 105, 3668, 3668],
        [420, 105, 3668, 3668],
    ],
    [
        [300, 555, 6408, 6408],
        [180, 495, 3668, 3668],
        [420, 495, 3668, 3668],
    ]
];
//reduces jitter (collisions)
var bounce = 10;
//current troop
var selected = 0;
//selected or deck selection
var selecteed = -1;
//Different deck variables: deck is deck and displayed is order
var displayed = savecode[4];
//elixir
var elixir = 5;
//money!
var money = savecode[1];
var fakemoney = money;
//debug purposes
var k = millis();
//splashes
var splashes = [];
//background
var bk = 255;
//init
var init = "Select";
//time in game
var time = 180;
//so it looks good with no outline
noStroke();
//frameRate
frameRate(58);
//stuff
var c = [false, false];
//cool text
textFont(createFont("cursive"));
//makes the rects in the center
rectMode(CENTER);
//enemy emotes
var emotes = ["🤣", "😒", "😎", "🙄", "😴", "🤬", "😭", "🥱"];
//your emotes
var yemotes = emotes;
//tips
var tips = ['You must have a full deck to battle.', 'You can upgrade your towers using coins.', 'Some cards are scuffed.', 'Use Elixir efficiently.', 'Save your game frequently.', 'Upgrade your cards.', 'Three crowning earns more coins.', 'Balance your deck.', 'Try out the different codes.', 'Have common sense.', 'Spamming is dangerous.', 'Moving your mouse out will pause the game.', 'Play often.', 'There are many arenas.', 'The more trophies you have, the harder the enemies.', 'There are air, ground, tower, and spell cards.', 'Read the how page.', 'The shop refreshes every minute.', 'Common cards can beat Champions if used properly.', 'Switching your arena will only change graphics.', 'Wait or pay coins to refresh the shop.', 'The leaderboard is fake.', '14 is the max level.', 'Touchscreen works.', 'You can lose trophies.'];
//what the opponent places next
var nextplacement = [floor(random(types.length)), [300, 300]];
//enemy'S elixir
var enemyelixir = 5;
var pm = 0;
//card color for rarities
var cardcolors = [color(0, 200, 255), color(255, 163, 26), color(179, 0, 179), color(0, 0, 0), color(255, 226, 0), color(0, 0, 0)];
var costs = [5, 50, 500, 20000, 40000, 1000000];
var upgradeCost = [5, 20, 50, 150, 400, 1000, 2000, 4000, 8000, 15000, 35000, 75000, 100000];
var startingLevels = [1, 3, 6, 9, 11, 1];
//arena colors
var arenacolors = [
    [0, 160, 0],
    [210, 187, 163],
    [0, 200, 0],
    [50, 50, 50],
    [0, 128, 128],
    [186, 140, 99],
    [0, 220, 0],
    [0, 200, 255],
    [30 * 2, 56 * 2, 33 * 2],
    [150, 150, 150],
    [0, 0, 50],
    [36 * 2 / 3, 133 * 2 / 3, 122],
    [100, 200, 100],
    [212, 179, 49],
    [242, 0, 255],
    [255, 200, 0],
];
var arenanames = ['Goblin stadium', 'Bone pit', 'Barbarian bowl', 'Pekka\'s playhouse', 'Spell valley', 'Builder\'s workshop', 'Royal arena', 'Frozen peak', 'Jungle arena', 'Hog mountain', 'Electro valley', 'Spooky town', 'Snowy plains', 'Haunted island', 'Flower fields', 'Gold river'];
var colory = color(0, 0, 50);
//colors of the background
var backcolors = [
    [0, 180, 0],
    [210, 187, 163],
    [0, 220, 0],
    [255, 150, 0],
    [0, 128, 128],
    [186, 140, 99],
    [0, 220, 0],
    [0, 200, 255],
    [30 * 2, 56 * 2, 33 * 2],
    [0, 240, 0],
    [0, 255, 240],
    [36 / 2, 112 / 2, 102],
    [255, 255, 255],
    [0, 200, 255],
    [157, 0, 255],
    [255, 180, 0],
];
//blood
var blood = [];
//what arena you are in: 0-100 is arena 1, 100-200 is arena 2, etc
var arena = 0;
var realarena = 0;
//which tip to show
var ct = 0;
//which emote to show
var g = 0;
//enemy trophies
var etrophies = 0;
//enemy tower level
var etowerlev = 0;
var how = false;
//showing a message
var msg = ["CLASH ROYALE", 1];
//for you
var h = 0;
var secondee = function() {
    return round(second() + minute() % 5 * 60);
};
var log2 = function(x) {
    return log(x) / log(2) * 10;
};
//}
//text {
var bad = 'qwertyuiopasdfghjklzxcvbnm';
var good = 'QWERTYUIOPASDFGHJKLZXCVBNM';
var lower = {};
for (var i = 0; i < bad.length; i++) {
    lower[bad[i]] = good[i];
}
var text2 = function(txt, x, y, w, h) {
    // var ntxt = [];
    // for (var i = 0; i < txt.length; i++) {
    //     ntxt.push(txt[i]);
    // }
    // if (bad.includes(ntxt[0])) {
    //     ntxt[0] = lower[ntxt[0]];
    // }
    // txt = '';
    // for (var j = 0; j < ntxt.length; j++) {
    //     txt += ntxt[j];
    // }
    if (!w) {
        text(txt, x, y);
    } else {
        text(txt, x, y, w, h);
    }
};
//}
//draw stuff {
var legcolor = function() {
    var frameeCount = frameCount / 2;
    var timee = frameeCount % 40;
    if (timee <= 10) {
        return lerpColor(color(214, 138, 176), color(216, 206, 93), frameeCount % 40 / 10);
    } else if (timee <= 20) {
        return lerpColor(color(216, 206, 93), color(107, 216, 93), (frameeCount % 40 - 10) / 10);
    } else if (timee <= 30) {
        return lerpColor(color(107, 216, 93), color(93, 185, 216), (frameeCount % 40 - 20) / 10);
    } else if (timee <= 40) {
        return lerpColor(color(93, 185, 216), color(214, 138, 176), (frameeCount % 40 - 30) / 10);
    }
    return color(255, 0, 0);
};
var champcolor = function() {
    return color(255, 230 + sin(frameCount * 180 / 20) * 20, 0);
};
//cursor
var cursar = function() {
    this.cursor("None");
    strokeWeight(1);
    fill(0, 0, 0);
    stroke(255, 255, 255);
    if (mouseIsPressed) {
        strokeWeight(2);
    }
    pushMatrix();
    translate(mouseX, mouseY);
    rotate(90 - 20);
    translate(-mouseX, -mouseY);
    rect(mouseX + 15 + 4, mouseY - 4 + 2.5, 8, 5);
    popMatrix();
    quad(mouseX, mouseY, mouseX, mouseY + 20, mouseX + 7.5, mouseY + 15, mouseX + 15, mouseY + 15);
    noStroke();
};
var drawbubble = function(x, y, s) {
    stroke(0, 0, 0);
    strokeWeight(s / 20);
    fill(255, 255, 255);
    triangle(x + s / 2, y, x + s * 2 / 3, y + s / 3, x, y + s / 3);
    rect(x, y, s, s * 2 / 3, s / 4);
    noStroke();
    fill(255, 255, 255);
    triangle(x + s / 2 - s / 30, y, x + s * 2 / 3 - s / 40, y + s / 3 - s / 60, x, y + s / 3 - s / 40);
    noStroke();
};
//draws a droplet at position x, y with size s (just a circle + triangle
var drawelixir = function(x, y, s) {
    fill(255, 0, 255);
    ellipse(x, y, s, s);
    triangle(x - s / 2 + s / 16, y - s / 4, x + s / 2 - s / 16, y - s / 4, x, y - s);
    stroke(200, 0, 255);
    strokeWeight(s / 8);
    arc(x, y, s / 2, s / 2, 30, 210);
    noStroke();
    fill(255, 255, 255, 150);
    ellipse(x + s / 12, y - s / 4, s / 3, s / 3);
};
//draws trophies
var drawtrophy = function(x, y, s) {
    fill(255, 215, 12);
    arc(x, y, s * 3 / 4, s * 3 / 2, 0, 180);
    rect(x, y + s / 2, s / 4, s);
    rect(x, y + s, s * 3 / 4, s / 4, s / 8);
    noFill();
    stroke(255, 215, 12);
    strokeWeight(s / 8);
    ellipse(x, y + s / 3, s, s / 2);
    noStroke();
};
//draws a polygon
var poly = function(x, y, s, d, r) {
    pushMatrix();
    translate(x, y);
    rotate(r);
    translate(-x, -y);
    for (var i = 0; i < d; i++) {
        var theta = i / d * 360;
        line(x + cos(theta) * s / 2, y + sin(theta) * s / 2, x + cos((i + 1) / d * 360) * s / 2, y + sin((i + 1) / d * 360) * s / 2);
    }
    for (var i = 0; i < d; i++) {
        for (var j = 0; j < d; j++) {
            var td = i / d * 360;
            var tj = j / d * 360;
            triangle(x + cos(td) * s / 2, y + sin(td) * s / 2, x + cos(tj) * s / 2, y + sin(tj) * s / 2, x + cos(0) * s / 2, y + sin(0) * s / 2);
        }
    }
    popMatrix();
};
//draws money (make better)
var drawmoney = function(x, y, s) {
    /*
    noStroke();
    fill(0, 200, 0);
    poly(x, y, s, 6, 30);
    fill(0, 255, 0);
    poly(x, y, s * 3 / 5, 6, 30);
    */
    fill(255, 215, 0);
    stroke(240, 170, 0);
    noStroke();
    strokeWeight(s / 8);
    ellipse(x, y, s + s / 8, s + s / 8);
    noFill();
    for (var i = -45; i < 360 - 45; i += 7) {
        stroke(lerpColor(color(255, 255, 255), color(240, 170, 0), pow(min(abs(i + 45), abs(360 - (i + 45))) / 180, 0.5)));
        point(x + cos(i) * s / 2, y + sin(i) * s / 2);
    }
    strokeWeight(s / 3);
    for (var i = -45; i < 360 - 45; i += 7) {
        stroke(lerpColor(color(255, 255, 255), color(240, 170, 0), 1 - pow(min(abs(i + 45), abs(360 - (i + 45))) / 180, 1.5)));
        point(x + cos(i) * s / 6, y + sin(i) * s / 6);
    }
    stroke(240, 170, 0);
    strokeWeight(s / 12);
    ellipse(x, y, s - s / 4, s - s / 4);
};
var diamondbackground = null;
//blue diamond background
var diamond = function() {
    if (!diamondbackground) {
        background(0, 79, 136);
        for (var k = -100 + mouseX / 10; k <= 650; k += 50) {
            for (var l = -100 + mouseY / 10; l <= 650; l += 50) {
                fill(0, 79, 136);
                quad(k - 25, l, k, l - 25, k + 25, l, k, l + 25);
                fill(14, 64, 113);
                quad(k, l + 25, k + 25, l - 50 + 50, k + 50, l + 25, k + 25, l + 50);
            }
        }
        diamondbackground = get(0, 0, 600, 600);
    } else {
        image(diamondbackground, mouseX / 4 - 150, mouseY / 4 - 150, 750, 750);
    }
};
//}
//deck selection stuff {
var cheese = false;
//shows the deck
var showdeck = function() {
    if (!how & !cheese) {
        //deck
        textSize(17.5);
        var avg = 0;
        for (var i = 0; i < displayed.length; i++) {
            fill(types[displayed[i]][15] === 3 ? legcolor() : (types[displayed[i]][15] === 4 ? champcolor() : cardcolors[types[displayed[i]][15]]));
            stroke(0, 150, 255);
            strokeWeight(4);
            rect(200 + i % 2 * 200, 440 + floor(i / 2) * 40 + 15, 190, 30, 5);
            noStroke();
            textAlign(CENTER, CENTER);
            fill(255, 255, 255);
            text2(types[displayed[i]][8] + " ", 200 + i % 2 * 200, 440 + floor(i / 2) * 40 + 15);
            textAlign(RIGHT, CENTER);
            text2(types[displayed[i]][9] + " ", 200 + i % 2 * 200 + 80, 440 + floor(i / 2) * 40 + 15);
            drawelixir(200 + i % 2 * 200 + 82.5, 440 + floor(i / 2) * 40 + 17.5, 12.5);
            avg += types[displayed[i]][9] / displayed.length;
        }
        textAlign(CENTER, CENTER);
        fill(255, 255, 255);
        textSize(20);
        text2("Average: " + floor(avg) + "." + (floor(avg * 10) - floor(avg) * 10), 417.5, 425);
        drawelixir(487.5, 427.5, 15);
    }
};
var shiftit = 0;
var preshift = shiftit;
var bricks = null;
//draws the brown bricks
var drawbricks = function() {
    if (!bricks) {
        noStroke();
        for (var y = 0; y < 226; y += 25) {
            fill((300 + y) % 2 === 0 ? color(0, 180, 255) : color(0, 150, 255));
            rect(300, y + 12.5, 600, 25);
        }
        fill(0, 120, 255);
        for (var x = -1225; x < 1825; x += 100) {
            for (var y = 12.5; y < 250; y += 25) {
                if (x - (shiftit - 300) * 4 + (((y + 12.5) / 25) % 2 === 0 ? 50 : 0) > -20 & x - (shiftit - 300) * 4 + (((y + 12.5) / 25) % 2 === 0 ? 50 : 0) < 620) {
                    rect(x - (shiftit - 300) * 4 + (((y + 12.5) / 25) % 2 === 0 ? 50 : 0), y, 4, 25);
                }
            }
        }
        bricks = get(0, 0, 600, 262.5);
    } else {
        image(bricks, 0, 0, 600, 262.5);
    }
};
//shhhh...
var showstuff = function() {
    fill(255, 255, 255);
    textSize(25);
    text2("Cards:", -125 - (mouseX - 300) * 4 - 1200 + 200, 125);
    text2("Hi there", 2700 - (mouseX - 300) * 4 - 1200 + 200, 125);
};
var ggggg = false;
//shows the cards for selection
var showcards = function() {
    //all the cards
    for (var i = 0; i < types.length; i++) {
        if (floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200 > -50 & floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200 < 650) {
            fill(0, 180, 255);
            stroke(types[i][15] === 3 ? legcolor() : (types[i][15] === 4 ? champcolor() : cardcolors[types[i][15]]));
            strokeWeight(6);
            if (displayed.includes(i)) {
                fill(0, 220, 0);
            } else if (types[i][14] > 0) {
                fill(0, 150, 255);
            }
            if (mouseX > floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200 - 47.5 & mouseX < floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200 + 47.5 & mouseY < i % 3 * 80 + 40 + 37.5 & mouseY > i % 3 * 80 + 40 - 37.5 || selecteed === i) {
                fill(0, 120, 255);
                strokeWeight(6);
            }
            rect(floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200, i % 3 * 80 + 40, 85, 65, 5);
            noStroke();
            fill(types[i][14] > 0 ? types[i][12] : color(0, 0, 0));
            ellipse(floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200, i % 3 * 80 + 40, 40, 40);
            fill(types[i][14] > 0 ? types[i][13] : color(0, 0, 0));
            rect(floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 220, i % 3 * 80 + 40, 80 / 3, 40 / 4, 40 / 8);
            fill(255, 255, 255);
            textSize(12);
            if (types[i][14] <= 0) {
                textSize(16);
            }
            if (types[i][14] === 14) {
                fill(255, 215, 0);
            }
            text2(types[i][14] > 0 ? types[i][8] : "???", floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200, i % 3 * 80 + 40);
            fill(255, 255, 255);
            textSize(12);
            text2(types[i][14] > 0 ? types[i][9] : "?", floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200 + 20, i % 3 * 80 + 60);
            if (types[i][14] === 14) {
                fill(255, 215, 0);
            }
            text2("Lvl " + (types[i][14] > 0 ? types[i][14] : "?"), floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200 - (types[i][14] > 10 ? 20 : 22.5), i % 3 * 80 + 60);
            fill(255, 255, 255);
            noStroke();
            drawelixir(floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200 + 30, i % 3 * 80 + 62.5, 10);
        } else if (floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200 >= 650) {
            break;
        }
    }
    fill(255, 255, 255);
    textSize(20);
    textAlign(CENTER, CENTER);
    text2("Drag to scroll", -(shiftit - 300) * 4 - 1200 + 75, 125);
    fill(0, 180, 255);
    rect(300, 250, 610, 10, 5);
    fill(0, 120, 255);
    rect(shiftit, 250, 50, 10, 10);
    shiftit = constrain(shiftit, 0, 600);
    if (mouseIsPressed) {
        shiftit = preshift + (pm - mouseX) / 4;
        shiftit = constrain(shiftit, 0, 600);
    }
};
//shows the play button
var showplay = function() {
    noStroke();
    textAlign(CENTER, CENTER);
    fill(255, 215, 0);
    stroke(240, 170, 0);
    strokeWeight(5);
    //play button
    if (mouseX > 250 & mouseX < 350 & mouseY > 355 & mouseY < 405) {
        fill(0, 120, 255);
    }
    rect(300, 380, 125, 50, 5);
    fill(255, 0, 0);
    //if deck full, allow play
    if (displayed.length === 8) {
        fill(255, 255, 255);
    }
    textSize(25);
    text2("Battle", 300, 380);
    noStroke();
};
//shows the card'S stats
var showcardstats = function() {
    for (var i = 0; i < types.length; i++) {
        if (selecteed === i) {
            textSize(16);
            fill(255, 255, 255);
            //text2("Level " + types[i][14] + " " + types[i][8] + "\n" + "DPS: " + (types[i][14] > 0 ? floor(types[i][2] * cardlevelmult[types[i][14]] / types[i][3] * 60) : "???") + " Health: " + (types[i][14] > 0 ? round(types[i][0] * cardlevelmult[types[i][14]]) : "???") + " Range: " + (types[i][14] > 0 ? types[i][1] : "???") + " Speed: " + (types[i][14] > 0 ? types[i][5] : "???") + " Area of Effect: " + (types[i][14] > 0 ? types[i][4] : "???") + "\nDescription: " + (types[i][14] > 0 ? types[i][16] : "???"), 300, 287.5);
            text2("Level " + types[i][14] + " " + types[i][8] + "\n" + "Damage: " + floor(types[i][2] * cardlevelmult[types[i][14]] / types[i][3] * 60) + " Health: " + round(types[i][0] * cardlevelmult[types[i][14]]) + " Range: " + types[i][1] + " Speed: " + types[i][5] + " Area of Effect: " + types[i][4] + "\nDescription: " + types[i][16], 300, 287.5);
        }
    }

};
//}
//back {
//draws the back button
var drawbackbutton = function() {
    stroke(0, 150, 255);
    strokeWeight(4);
    fill(0, 180, 255);
    if (dist(mouseX, mouseY, 550, 550) <= 37.5) {
        fill(0, 120, 255);
    }
    ellipse(550, 550, 75, 75);
    fill(255, 255, 255);
    textSize(20);
    textAlign(CENTER, CENTER);
    text2("Back", 550, 550);
};
//}
//leaderboard {
var leaderboard = [
    ["ThriftyPiano", 10000],
    ["Harry", 1980],
    ["Ian", 1370],
    ["Jack", 1290],
    ["Fred", 1100],
    ["George", 1020],
    ["Doug", 950],
    ["Liam", 880],
    ["Charles", 770],
    ["Jeff", 610],
    ["Tom", 520],
    ["Sam", 400],
    ["Joe", 230],
    ["Billy", 130],
    ["Bob", 20]
];
//shows the leaderboard
var showleaderboard = function() {
    if (cheese) {
        for (var i = 0; i < leaderboard.length; i++) {
            if (leaderboard[i][0] === "You") {
                leaderboard.splice(i, 1);
            }
        }
        for (var i = 0; i < leaderboard.length; i++) {
            if (trophies >= leaderboard[i][1]) {
                leaderboard.splice(i, 0, ["You", trophies]);
                break;
            }
        }
        if (trophies < 20) {
            leaderboard.push(["You", trophies]);
        }
        diamond();
        fill(0, 180, 255);
        stroke(0, 150, 255);
        strokeWeight(4);
        rect(300, 320, 300, 525, 10);
        textAlign(CENTER, CENTER);
        textSize(30);
        fill(255, 255, 255);
        text2("| Leaderboard |", 300, 30);
        for (var i = 0; i < leaderboard.length; i++) {
            if (leaderboard[i][0] === "You") {
                fill(0, 120, 255);
                textSize(27.5);
            } else {
                textSize(22.5);
                fill(255, 255, 255);
            }
            text2((i + 1) + ". " + leaderboard[i][0] + " | " + leaderboard[i][1], 300, 75 + 32.5 * i);
            noStroke();
            drawtrophy(432.5, 65 + 32.5 * i, 17.5);
        }
        drawbackbutton();
    }
};
//}
//game {
//background stuff {
var trees = [];
for (var i = 0; i < 100; i++) {
    trees.push([random(-50, 25) + round(random(0, 1)) * 500 + 50, random(0, 600), random(25, 50), random(0, 20)]);
}
//trees
var drawtrees = function() {
    for (var i = 0; i < trees.length; i++) {
        fill(0, constrain(trees[i][3] * 10 + 100, 0, 255), 0);
        rect(trees[i][0], trees[i][1], trees[i][2], trees[i][2], trees[i][2] / 4);
        fill(0, constrain((trees[i][3] * 10 + 100) * 3 / 4, 0, 255), 0);
        rect(trees[i][0], trees[i][1], trees[i][2] / 2, trees[i][2] / 2, trees[i][2] / 8);
    }
};
var arenaimages = [];
var fullarenaimages = [];
//draws the background
var drawback = function(arena) {
    if (!fullarenaimages[arena]) {
        background(backcolors[arena][0], backcolors[arena][1], backcolors[arena][2]);
        stroke(0, 0, 0);
        strokeWeight(0.25);
        fill(arenacolors[arena][0], arenacolors[arena][1], arenacolors[arena][2]);
        for (var k = -10; k <= 600; k += 40) {
            for (var l = 120; l <= 480; l += 40) {
                rect(l, k, 18, 18);
            }
        }
        for (var k = -10 + 20; k <= 600; k += 40) {
            for (var l = 120 + 20; l <= 480; l += 40) {
                rect(l, k, 18, 18);
            }
        }
        fill(arenacolors[arena][0] * 1.1, arenacolors[arena][1] * 1.1, arenacolors[arena][2] * 1.1);
        for (var k = -10; k <= 600; k += 40) {
            for (var l = 120 + 20; l <= 480; l += 40) {
                rect(l, k, 16, 16);
            }
        }
        for (var k = -10 + 20; k <= 600; k += 40) {
            for (var l = 120; l <= 480; l += 40) {
                rect(l, k, 16, 16);
            }
        }
        noFill();
        strokeWeight(25);
        stroke(arenacolors[arena][0] * 1.2, arenacolors[arena][1] * 1.2, arenacolors[arena][2] * 1.2);
        rect(300, 300, 240, 500, 5);
        noStroke();
        //draws the middle line
        rectMode(CENTER);
        fill(0, 200, 255);
        rect(300, 300, 600, 20);
        fill(101, 82, 57);
        var bob = 200;
        rect(bob % 750 - 100, 300, 50, 20, 5);
        rect((bob + 80) % 750 - 100, 300, 50, 20, 5);
        rect((bob - 120) % 750 - 100, 300, 50, 20, 5);
        rect((bob - 250) % 750 - 100, 300, 50, 20, 5);
        rect((bob + 240) % 750 - 100, 300, 50, 20, 5);
        drawtrees();
        for (var i = 0; i < 50; i += 20) {
            fill(lerpColor(color(202, 164, 114), color(101, 82, 57), 1 - i / 50));
            rect(180, 300, 40, 50 - i);
            rect(420, 300, 40, 50 - i);
        }
    } else {
        image(fullarenaimages[arena], 0, 0, 600, 600);
    }
};
var getarenaimages = function() {
    for (var i = 0; i < arenacolors.length; i++) {
        drawback(i);
        arenaimages.push(get(0, 200, 600, 200));
        fullarenaimages.push(get(0, 0, 600, 600));
    }
};
//spawns a troop with position (x, y), type t, side s please ignore this
//}
//functions{
var spawntroop = function(x, y, t, s) {
    if (s === 0) {
        for (var i = 0; i < types[t][7]; i++) {
            troops.push([x, y, types[t][0] * cardlevelmult[types[t][14]], types[t][1], types[t][2] * cardlevelmult[types[t][14]], types[t][3], types[t][4], types[t][5], types[t][6], s, null, 0, types[t][0] * cardlevelmult[types[t][14]], types[t][8], types[t][2] * cardlevelmult[types[t][14]], types[t][11], types[t][12], types[t][13], 0, types[t][7], types[t][14], false]);
            troops[troops.length - 1][10] = troops.length - 1;
        }
    } else {
        //Card Level!
        var garge = constrain(realarena + round(random(4, -2)), startingLevels[types[t][15]], 14);
        if (t === types.length - 1) {
            garge = etowerlev;
        }
        if (types[t][0] > 0 & types[t][8] !== "Goblin barrel" & types[t][8] !== "Miner") {
            y = constrain(y, 0, 280);
        }
        for (var i = 0; i < types[t][7]; i++) {
            troops.push([x, y, types[t][0] * cardlevelmult[garge], types[t][1], types[t][2] * cardlevelmult[garge], types[t][3], types[t][4], types[t][5], types[t][6], s, null, 0, types[t][0] * cardlevelmult[garge], types[t][8], types[t][2] * cardlevelmult[garge], types[t][11], types[t][12], types[t][13], 0, types[t][7], garge, false]);
            troops[troops.length - 1][10] = troops.length - 1;
        }
    }
};
//closest tower
var closesttower = function(s, n) {
    var closest = 0;
    for (var j = 0; j < towers[s].length; j++) {
        if (dist(towers[s][j][0], towers[s][j][1], troops[n][0], troops[n][1]) <= dist(towers[s][closest][0], towers[s][closest][1], troops[n][0], troops[n][1]) & towers[s][j][2] > 0) {
            closest = j;
        }
    }
    return closest;
};
//Returns the target pos for a troop
var p = function(n1, n2) {
    if (n1 === n2) {
        return towers[troops[n2][9]][closesttower(troops[n2][9], n2)];
    } else if (n1 !== n2) {
        return troops[n1];
    }
};
//Returns the distance between a troop and its target
var d = function(n1, n2) {
    if (n1 === n2) {
        return dist(troops[n2][0], troops[n2][1], towers[troops[n2][9]][closesttower(troops[n2][9], n2)][0], towers[troops[n2][9]][closesttower(troops[n2][9], n2)][1]);
    } else {
        return dist(troops[n2][0], troops[n2][1], troops[n1][0], troops[n1][1]);
    }
};
//Returns the distance between two troops
var f = function(n1, n2) {
    return dist(troops[n2][0], troops[n2][1], troops[n1][0], troops[n1][1]);
};
var assignfreeze = function(index, freeze) {
    troops[index][10] = index;
    var reload = troops[index][11];
    //if greater: subtract
    troops[index][11] = (true) ? (reload + freeze) : (freeze);
};
//mouse side
var mouseside = function() {
    if (code === "dev") {
        return true;
    }
    if (towers[0][1][2] <= 0 & towers[0][2][2] <= 0) {
        if (round((mouseY - 10) / 20) * 20 + 10 >= 200) {
            return true;
        }
    }
    if (towers[0][1][2] > 0 & towers[0][2][2] > 0) {
        if (round((mouseY - 10) / 20) * 20 + 10 >= 320) {
            return true;
        }
    }
    if (towers[0][1][2] <= 0 & towers[0][2][2] > 0) {
        if (round(mouseX / 20) * 20 <= 320) {
            if (round((mouseY - 10) / 20) * 20 + 10 >= 200) {
                return true;
            }
        } else {
            if (round((mouseY - 10) / 20) * 20 + 10 >= 300) {
                return true;
            }
        }
    }
    if (towers[0][1][2] > 0 & towers[0][2][2] <= 0) {
        if (round(mouseX / 20) * 20 >= 300) {
            if (round((mouseY - 10) / 20) * 20 + 10 >= 200) {
                return true;
            }
        } else {
            if (round((mouseY - 10) / 20) * 20 + 10 >= 300) {
                return true;
            }
        }
    }
    return false;
};
var numb = 0;
//Counts millis, used for debugging purposes
var cinit = function() {
    k = millis();
    numb = 0;
};
var ccont = function() {
    println(numb + ": " + (millis() - k));
    k = millis();
    numb++;
};
//}
//troops {
//draws troops
var drawtroops = function() {
    //Draws the troop itself
    fill(0, 0, 0);
    for (var i = 0; i < troops.length; i++) {
        // strokeWeight(troops[i][8] / 10);
        // stroke(troops[i][9] !== 0 ? color(255, 0, 0) : color(0, 0, 255));
        // if(troops[i][20] === 13) {
        //     stroke(255, 215, 0);
        // }
        noStroke();
        if (troops[i][15][0] === 1) {
            fill(0, 0, 0, 100);
            ellipse(troops[i][0], troops[i][1] + 10, troops[i][8], troops[i][8]);
        }
        //Center circle
        fill(troops[i][16]);
        ellipse(troops[i][0], troops[i][1], troops[i][8], troops[i][8]);
        if (troops[i][11] < 0) {
            fill(112, 255, 255);
            ellipse(troops[i][0], troops[i][1], troops[i][8], troops[i][8]);
        }
        noStroke();
        //Arm
        fill(troops[i][17]);
        pushMatrix();
        translate(troops[i][0], troops[i][1]);
        var g = atan2(p(troops[i][10], i)[1] - troops[i][1], p(troops[i][10], i)[0] - troops[i][0]);
        if (p(troops[i][10], i)[1] > 300 & troops[i][1] < 300 || p(troops[i][10], i)[1] < 300 & troops[i][1] > 300) {
            if (troops[i][15][0] !== 1) {
                g = atan2(300 - troops[i][1], (troops[i][0] < 300 ? 180 : 420) - troops[i][0]);
            }
        }
        if (d(troops[i][10], i) <= troops[i][3] - 1) {
            g = atan2(p(troops[i][10], i)[1] - troops[i][1], p(troops[i][10], i)[0] - troops[i][0]);
        }
        rotate(g);
        translate(-troops[i][0], -troops[i][1]);
        rect(troops[i][0] + troops[i][8] * 2 / 3 - troops[i][8] * constrain(troops[i][11], 0, 10000) / troops[i][5] / 3, troops[i][1], troops[i][8] * 2 / 3, troops[i][8] / 3, troops[i][8] / 4);
        popMatrix();
        //Label
        if (dist(mouseX, mouseY, troops[i][0], troops[i][1]) <= troops[i][8] || true) {
            fill(255, 255, 255);
            textAlign(CENTER, CENTER);
            textSize(10);
            text2(troops[i][13], troops[i][0], troops[i][1] + troops[i][8] / 2 + 15);
        }
    }
    //Draws range
    for (var i = 0; i < troops.length; i++) {
        fill(0, 0, 0, 10);
        ellipse(troops[i][0], troops[i][1], troops[i][3] * 2, troops[i][3] * 2);
    }
    //Draws bars
    for (var i = 0; i < troops.length; i++) {
        troops[i][12] = constrain(troops[i][12], 0, troops[i][2]);
        if (troops[i][13] === "Princess tower" || troops[i][13] === "King tower") {

        } else {
            //Health bar
            rectMode(CENTER);
            fill(0, 0, 0, 100);
            rect(troops[i][0], troops[i][1] - troops[i][8] / 2 - 5, troops[i][8] * 1.5, 5, 10);
            fill(troops[i][9] !== 0 ? color(255, 0, 0) : color(0, 200, 255));
            rect(troops[i][0] + ((troops[i][8] * 1.5 * troops[i][12] / troops[i][2]) - troops[i][8] * 1.5) / 2, troops[i][1] - troops[i][8] / 2 - 5, troops[i][8] * 1.5 * troops[i][12] / troops[i][2], 5, 10);
        }
        fill(troops[i][9] !== 0 ? color(255, 0, 0, 200) : color(0, 200, 255, 200));
        if (troops[i][20] === 14) {
            fill(255, 215, 0, 200);
        }
        rect(troops[i][0] - troops[i][8] * 3 / 2 + 5, troops[i][1] - troops[i][8] / 2 - 5, 15, 15, 5);
        fill(255, 255, 255);
        textSize(12);
        textAlign(CENTER, CENTER);
        text2(troops[i][20], troops[i][0] - troops[i][8] * 3 / 2 + 5, troops[i][1] - troops[i][8] / 2 - 5);
        //Reload bar
        //fill(0, 0, 0);
        //rect(troops[i][0], troops[i][1] + troops[i][8] / 2 + 5, troops[i][8] * 1.5, 5, 10);
        //fill(255, 255, 0);
        //rect(troops[i][0], troops[i][1] + troops[i][8] / 2 + 5, troops[i][8] * 1.5 * troops[i][11] / troops[i][5], 5, 10);
    }
};
var movetroops = function() {
    //Moves
    for (var i = 0; i < troops.length; i++) {
        if (troops[i][11] >= 0) {
            var g = atan2(p(troops[i][10], i)[1] - troops[i][1], p(troops[i][10], i)[0] - troops[i][0]);
            if (p(troops[i][10], i)[1] > 300 & troops[i][1] < 300 || p(troops[i][10], i)[1] < 300 & troops[i][1] > 300) {
                if (troops[i][15][0] !== 1) {
                    g = atan2(300 - troops[i][1], (troops[i][0] < 300 ? 180 : 420) - troops[i][0]);
                }
            }
            if (d(troops[i][10], i) > troops[i][3] - 1) {
                if (from > 0) {
                    troops[i][0] += cos(g) * troops[i][7] * 60 / from;
                    troops[i][1] += sin(g) * troops[i][7] * 60 / from;
                }
            }
            troops[i][0] = constrain(troops[i][0], 100 + troops[i][8] / 2, 500 - troops[i][8] / 2);
            troops[i][1] = constrain(troops[i][1], troops[i][8] / 2, 600 - troops[i][8] / 2);
        }
    }
};
var collidetroops = function() {
    //Collisions w/ towers
    for (var i = 0; i < troops.length; i++) {
        for (var j = 0; j < towers.length; j++) {
            for (var k = 0; k < towers[j].length; k++) {
                if (dist(troops[i][0], troops[i][1], towers[j][k][0], towers[j][k][1]) <= troops[i][8] / 2 + 25 & troops[i][7] > 0 & towers[j][k][2] > 0) {
                    var r = atan2(troops[i][1] - towers[j][k][1], troops[i][0] - towers[j][k][0]);
                    while (dist(troops[i][0], troops[i][1], towers[j][k][0], towers[j][k][1]) <= troops[i][8] / 2 + 25) {
                        troops[i][0] += cos(r) / bounce * troops[i][7];
                        troops[i][1] += sin(r) / bounce * troops[i][7];
                    }
                }
            }
        }
    }
    //Collisions w/ other stuff
    if (troops.length > 1) {
        for (var j = 0; j < troops.length; j++) {
            for (var i = 0; i < troops.length; i++) {
                if (i !== j) {
                    if (dist(troops[i][0], troops[i][1], troops[j][0], troops[j][1]) <= troops[i][8] / 2 + troops[j][8] / 2 + 1 & troops[i][7] > 0 & troops[j][7] > 0 & troops[j][15][0] === troops[i][15][0]) {
                        var r = atan2(troops[j][1] - troops[i][1], troops[j][0] - troops[i][0]);
                        while (dist(troops[i][0], troops[i][1], troops[j][0], troops[j][1]) <= troops[i][8] / 2 + troops[j][8] / 2 + 1) {
                            var k = 0;
                            if (d(troops[j][10], j) > troops[j][3] - 1) {
                                troops[j][0] += cos(r) / bounce / troops[i][7] / troops[i][7];
                                troops[j][1] += sin(r) / bounce / troops[i][7] / troops[i][7];
                            } else {
                                k += 1;
                            }
                            if (d(troops[i][10], i) > troops[i][3] - 1) {
                                troops[i][0] -= cos(r) / bounce / troops[i][7] / troops[i][7];
                                troops[i][1] -= sin(r) / bounce / troops[i][7] / troops[i][7];
                            } else {
                                k += 1;
                            }
                            if (k >= 2) {
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
};
var interacttroops = function() {
    //Selects target
    for (var i = 0; i < troops.length; i++) {
        if (d(troops[i][10], i) > troops[i][3] + (troops[i][10] === i ? 20 : troops[troops[i][10]][8] / 2)) {
            if (troops[i][13] === "Mega knight" || troops[i][13] === "Bandit" || troops[i][13] === "Prince" || troops[i][13] === "Dark Prince") {
                if (troops[i][21] === false & d(troops[i][10], i) > 6 * 20) {
                    troops[i][21] = true;
                    troops[i][4] *= 2;
                    troops[i][14] *= 2;
                    troops[i][7] *= 2;
                }
            }
            //If the distance between the troop and another is less than the distance between the troop and its target, set the troop as its target
            for (var j = 0; j < troops.length; j++) {
                if (i !== j) {
                    if (f(i, j) <= d(troops[i][10], i) & troops[i][9] !== troops[j][9] & troops[i][5] !== 0) {
                        if (troops[i][15][1] >= troops[j][15][0]) {
                            troops[i][10] = j;
                        }
                    }
                }
            }
            //If the distance between the troop and the tower it is attacking is less than the distance between the troop and its target, set the tower as its target
            if (dist(troops[i][0], troops[i][1], towers[troops[i][9]][closesttower(troops[i][9], i)][0], towers[troops[i][9]][closesttower(troops[i][9], i)][1]) <= d(troops[i][10], i) || d(troops[i][10], i) > 9 * 20) {
                if (towers[troops[i][9]][closesttower(troops[i][9], i)][2] > 0) {
                    troops[i][10] = i;
                }
            }
        }
    }
    //Reloads
    for (var i = 0; i < troops.length; i++) {
        if (d(troops[i][10], i) <= troops[i][3] + (troops[i][10] === i ? 20 : troops[troops[i][10]][8] / 2) & troops[i][11] < troops[i][5] & from !== 0) {
            troops[i][11] += 1 * 60 / from;
        } else if (troops[i][11] < 0) {
            troops[i][11] += 1 * 60 / from;
        }
        if (d(troops[i][10], i) > troops[i][3] + (troops[i][10] === i ? 20 : troops[troops[i][10]][8] / 2) & troops[i][11] > 0) {
            troops[i][11] = 0;
        }
    }
    //Attacks
    for (var i = 0; i < troops.length; i++) {
        var closetower = closesttower(troops[i][9], i);
        var newp = p(troops[i][10], i);
        //If it is close enough to its target
        if (d(troops[i][10], i) <= troops[i][3] + (troops[i][10] === i ? 20 : troops[troops[i][10]][8] / 2) & troops[i][11] >= troops[i][5] & troops[i][2] !== 0) {
            troops[i][11] = 0;
            if (troops[i][5] !== 0) {
                stroke(troops[i][17]);
                strokeWeight(troops[i][8] / 10);
                line(troops[i][0], troops[i][1], p(troops[i][10], i)[0], p(troops[i][10], i)[1]);
                noStroke();
            }
            if (troops[i][2] !== 0) {
                splashes.push([troops[i][5] === 0 ? troops[i][0] : newp[0], troops[i][5] === 0 ? troops[i][1] : newp[1], troops[i][6] * 2 + 5, 20]);
            }
            var g = troops[i][5] === 0 ? troops[i][0] : newp[0];
            var h = troops[i][5] === 0 ? troops[i][1] : newp[1];
            var gaaah = [g, h];
            //Selects depending on troop or tower
            for (var j = 0; j < troops.length; j++) {
                if (troops[i][9] !== troops[j][9] & dist(gaaah[0], gaaah[1], troops[j][0], troops[j][1]) <= troops[i][6] + troops[j][8] / 2 & troops[j][12] > 0 & troops[i][15][1] >= troops[j][15][0]) {
                    if (troops[i][13] === "Fisherman" & dist(gaaah[0], gaaah[1], troops[i][0], troops[i][1]) >= 1.2 * 20 + troops[j][8] / 2) {
                        if (troops[j][15][0] >= 0) {
                            troops[j][0] = troops[i][0];
                            troops[j][1] = troops[i][1];
                        } else {
                            troops[i][0] = troops[j][0];
                            troops[i][1] = troops[j][1];
                        }
                    } else {
                        if (troops[i][13] !== "Battle healer" || dist(gaaah[0], gaaah[1], troops[j][0], troops[j][1]) <= 1) {
                            if (troops[j][13] === "Princess tower" || troops[j][13] === "King tower") {
                                troops[j][12] -= troops[i][14];
                            } else {
                                troops[j][12] -= troops[i][4];
                            }
                        }
                        // troops[j][0] += troops[i][6]*troops[j][8]/(troops[j][0]-gaaah[0])/dist(troops[j][0], troops[j][1], gaaah[0], gaaah[1]);
                        // troops[j][1] += troops[i][6]*troops[j][8]/(troops[j][1]-gaaah[1])/dist(troops[j][0], troops[j][1], gaaah[0], gaaah[1]);
                        if (troops[i][13] === "Electro spirit") {
                            assignfreeze(j, -0.5 * 60);
                        } else if (troops[i][13] === "Ice spirit") {
                            assignfreeze(j, -1.3 * 60);
                        } else if (troops[i][13] === "Zappies") {
                            assignfreeze(j, -0.5 * 60);
                        } else if (troops[i][13] === "Electro dragon") {
                            assignfreeze(j, -0.5 * 60);
                        } else if (troops[i][13] === "Electro wizard") {
                            assignfreeze(j, -0.5 * 60);
                        } else if (troops[i][13] === "Ice wizard") {
                            assignfreeze(j, -0.25 * 60);
                        }
                    }
                } else if (troops[i][9] === troops[j][9] & dist(gaaah[0], gaaah[1], troops[j][0], troops[j][1]) <= troops[i][6] + troops[j][8] / 2 & troops[j][12] > 0 & troops[i][15][1] >= troops[j][15][0] & troops[i][13] === "Heal spirit" & troops[j][15][0] >= 0) {
                    troops[j][12] += troops[i][4] * 3.63;
                } else if (troops[i][9] === troops[j][9] & dist(gaaah[0], gaaah[1], troops[j][0], troops[j][1]) <= troops[i][6] + troops[j][8] / 2 & troops[j][12] > 0 & troops[i][15][1] >= troops[j][15][0] & troops[i][13] === "Battle healer" & troops[j][15][0] >= 0) {
                    troops[j][12] += troops[i][4] * 0.681;
                }
            }
            if (dist(towers[troops[i][9]][closetower][0], towers[troops[i][9]][closetower][1], newp[0], newp[1]) <= troops[i][6] / 2 + 10) {
                if (closetower > 0 || c[closetower] === true) {
                    towers[troops[i][9]][closetower][2] -= troops[i][14];
                } else {
                    /*
                    else {
                    c[closetower] = true;
                    var side = closetower;
                    spawntroop(towers[side][0][0], towers[side][0][1], types.length - 1, 1-side);
                    towers[troops[i][9]][closetower][2] -= troops[i][14];
                    troops[troops.length - 1][12] -= troops[i][14];
                }
                    */
                    c[closetower] = true;
                    var side = closetower;
                    spawntroop(towers[side][0][0], towers[side][0][1], types.length - 1, 1 - side);
                    towers[troops[i][9]][closetower][2] -= troops[i][14];
                    troops[troops.length - 1][12] -= troops[i][14];
                }
            }
            if (troops[i][13] === "Electro spirit" || troops[i][13] === "Fire spirit" || troops[i][13] === "Ice spirit" || troops[i][13] === "Heal spirit") {
                troops[i][12] = 0;
            }
            if (troops[i][13] === "Mega knight" || troops[i][13] === "Bandit" || troops[i][13] === "Prince" || troops[i][13] === "Dark Prince") {
                if (troops[i][21] === true) {
                    troops[i][4] /= 2;
                    troops[i][14] /= 2;
                    troops[i][7] /= 2;
                    troops[i][21] = false;
                }
            }
        }

        if (troops[i][2] === 0) {
            splashes.push([troops[i][0], troops[i][1], troops[i][6] * 2, 20]);
            var g = troops[i][0];
            var h = troops[i][1];
            var gaaah = [g, h];
            //Selects depending on troop or tower
            for (var j = 0; j < troops.length; j++) {
                if (troops[i][9] !== troops[j][9] & dist(gaaah[0], gaaah[1], troops[j][0], troops[j][1]) <= troops[i][6] + troops[j][8] / 2 & troops[j][12] > 0 & troops[i][15][1] >= troops[j][15][0]) {
                    if (troops[j][13] === "Princess tower") {
                        troops[j][12] -= troops[i][14];
                    } else if (troops[j][13] === "King tower") {
                        troops[j][12] -= troops[i][14];
                    } else {
                        troops[j][12] -= troops[i][4];
                    }
                    // troops[j][0] += troops[i][6]*troops[j][8]/(troops[j][0]-gaaah[0])/dist(troops[j][0], troops[j][1], gaaah[0], gaaah[1]);
                    // troops[j][1] += troops[i][6]*troops[j][8]/(troops[j][1]-gaaah[1])/dist(troops[j][0], troops[j][1], gaaah[0], gaaah[1]);
                    if (troops[i][13] === "Tornado" & troops[j][15][0] > -1) {
                        troops[j][0] = troops[i][0];
                        troops[j][1] = troops[i][1];
                    } else if (troops[i][13] === "Giant snowball") {
                        assignfreeze(j, -2.5 * 60);
                    } else if (troops[i][13] === "Freeze") {
                        assignfreeze(j, -4 * 60);
                    } else if (troops[i][13] === "Earthquake") {
                        assignfreeze(j, -1.5 * 60);
                    } else if (troops[i][13] === "Zap") {
                        assignfreeze(j, -0.5 * 60);
                    }
                }
            }
            /*
            c[i] = true;
                                var side = troops[j][9];
                                spawntroop(towers[side][0][0], towers[side][0][1], types.length - 1, 1 - side);
            */
            if (dist(towers[troops[i][9]][closetower][0], towers[troops[i][9]][closetower][1], troops[i][0], troops[i][1]) <= troops[i][6] + 10) {
                if (closetower > 0 || c[closetower] === true) {
                    towers[troops[i][9]][closetower][2] -= troops[i][14];
                } else {
                    c[closetower] = true;
                    var side = closetower;
                    spawntroop(towers[side][0][0], towers[side][0][1], types.length - 1, 1 - side);
                    towers[troops[i][9]][closetower][2] -= troops[i][14];
                    troops[troops.length - 1][12] -= troops[i][14];
                }
            }
        }
    }
};
var dietroops = function() {
    //Splices
    for (var i = troops.length - 1; i >= 0; i--) {
        if (troops[i][12] <= 0) {
            for (var k = 0; k < random(5, 10); k++) {
                var r = random(0, 360);
                var d = random(0, 10);
                blood.push([troops[i][0] + cos(r) * d, troops[i][1] + sin(r) * d, random(5, 10), 50]);
            }
            troops.splice(i, 1);
        }
    }
    //Prevents accessing bad indexes
    for (var i = 0; i < troops.length; i++) {
        if (troops[i][10] >= troops.length || troops[troops[i][10]][15][0] > troops[i][15][1]) {
            troops[i][10] = i;
        }
    }
    for (var i = 0; i < troops.length; i++) {
        if (troops[troops[i][10]][9] === troops[i][9] & i !== troops[i][10]) {
            troops[i][10] = i;
        } else if (troops[troops[i][10]][12] <= 0) {
            troops[i][10] = i;
        }
    }
};
//Iterates troops
var itertroops = function() {
    drawtroops();
    movetroops();
    collidetroops();
    interacttroops();
    dietroops();
};
//Spawns enemies
var spawntroops = function() {
    if (from > 0) {
        enemyelixir += 1 / from / 2.2 * (time < 60 ? 2 : 1);
    }
    nextplacement[1] = [random(0, 600), random(0, 400)];
    while (types[nextplacement[0]][15] === 5 || startingLevels[types[nextplacement[0]][15]] !== constrain(startingLevels[types[nextplacement[0]][15]], 0, realarena + 4)) {
        nextplacement[0] = floor(random(types.length));
    }
    if (enemyelixir >= types[nextplacement[0]][9]) {
        var k = nextplacement[0];
        var pos = [random(0, 600), random(0, 600)];
        if (types[k][3] === 0) {
            var selectedtroop = floor(random(0, troops.length));
            var hasselected = false;
            for (var i = selectedtroop; i < troops.length; i++) {
                if (troops[i][9] === 0) {
                    pos = [troops[i][0], troops[i][1]];
                    hasselected = true;
                    break;
                }
            }
            if (!hasselected) {
                for (var i = 0; i < troops.length; i++) {
                    if (troops[i][9] === 0) {
                        pos = [troops[i][0], troops[i][1]];
                        hasselected = true;
                        break;
                    }
                }
            } else {
                var selectedtower = round(random(1, 2));
                pos = [towers[1][selectedtower][0], towers[1][selectedtower][1]];
            }
        }
        nextplacement = [k, pos];
        spawntroop(constrain(nextplacement[1][0], 0, 600), constrain(nextplacement[1][1], 0, 600), nextplacement[0], 1);
        enemyelixir -= types[nextplacement[0]][9];
        nextplacement[0] = floor(random(types.length));
    }
};
//}
//}
//Main page stuff {
//shows your stats
var showstats = function() {
    fill(0, 180, 255);
    stroke(0, 150, 255);
    rect(435, 380, 120, 40, 5);
    rect(165, 380, 120, 40, 5);
    noStroke();
    textSize(25);
    fill(255, 215, 0);
    //stats + instructions + logo
    text2(trophies, 450, 380);
    drawtrophy(400, 370, 20);
    fill(255, 255, 255);
    textSize(20);
    text2(wl[0] + "/" + (wl[0] + wl[1]) + " Won", 165, 380);
    textSize(25);
    fill(255, 255, 255);
    textSize(constrain(250 / constrain(log(money), 1, 10000), 1, 25));
    text2(round(money), 550, 25);
    drawmoney(500, 25, 25);
};
//draws the clash royale logo
var drawlogo = function() {
    pushMatrix();
    // translate(300, 150);
    // rotate(sin(frameCount * 4) * 5);
    // translate(-300, -150);
    textSize(60);
    for (var k = 0; k < 6; k++) {
        fill(255, 150, 0);
        text2("Clash Royale", 300 - k, 50 - k);
    }
    fill(255, 220, 0);
    text2("Clash Royale", 300, 50);
    popMatrix();
    //Tips
    fill(0, 180, 255);
    if (mouseX > 300 - 175 & mouseX < 300 + 175 & mouseY > 325 - 15 & mouseY < 325 + 15) {
        fill(0, 120, 255);
    }
    strokeWeight(4);
    stroke(0, 150, 255);
    rect(300, 325, 350, 30, 10);
    fill(255, 255, 255);
    textSize(12.5);
    text2('Tip: ' + tips[ct], 300, 325);
};
//draws the buttons
var showbuttons = function() {
    stroke(0, 150, 255);
    strokeWeight(4);
    fill(0, 180, 255);
    //buy a thing button
    if (dist(mouseX, mouseY, 50, 550) <= 37.5) {
        fill(0, 120, 255);
    }
    ellipse(50, 550, 75, 75);
    fill(0, 180, 255);
    if (dist(mouseX, mouseY, 50, 450) <= 37.5) {
        fill(0, 120, 255);
    }
    ellipse(50, 450, 75, 75);
    fill(0, 180, 255);
    if (dist(mouseX, mouseY, 550, 450) <= 37.5) {
        fill(0, 120, 255);
    }
    ellipse(550, 450, 75, 75);
    fill(0, 180, 255);
    if (dist(mouseX, mouseY, 550, 350) <= 37.5) {
        fill(0, 120, 255);
    }
    ellipse(550, 350, 75, 75);
    fill(0, 180, 255);
    if (dist(mouseX, mouseY, 50, 350) <= 37.5) {
        fill(0, 120, 255);
    }
    ellipse(50, 350, 75, 75);
    textSize(20);
    fill(255, 255, 255);
    text2("Shop", 50, 550);
    text2("How", 50, 450);
    text2("Save", 550, 450);
    text2("Lead", 550, 350);
    text2("Deck", 50, 350);
    noStroke();
};
var drawarena = function() {
    fill(0, 180, 255);
    strokeWeight(4);
    stroke(0, 150, 255);
    rect(300, 175, 325, 120, 10);
    rect(300, 262.5, 325, 30, 10);
    fill(255, 255, 255);
    textSize(20);
    text(arenanames[arena], 300, 262.5);
    image(arenaimages[arena], 300 - 150, 125, 300, 100);
    fill(0, 180, 255);
    stroke(0, 150, 255);
    if (mouseX > 100 - 50 / 2 & mouseX < 100 + 50 / 2 & mouseY > 175 - 60 & mouseY < 175 + 60) {
        if (arena > 0) {
            fill(0, 120, 255);
        } else {
            fill(255, 0, 0);
        }
    }
    rect(100, 175, 50, 120, 5);
    fill(0, 180, 255);
    if (mouseX > 500 - 50 / 2 & mouseX < 500 + 50 / 2 & mouseY > 175 - 60 & mouseY < 175 + 60) {
        if (arena < realarena) {
            fill(0, 120, 255);
        } else {
            fill(255, 0, 0);
        }
    }
    rect(500, 175, 50, 120, 5);
    fill(255, 255, 255);
    textSize(80);
    text("<", 100, 175);
    text(">", 500, 175);
};
//}
//main page {
//select screen
var select = function() {
    diamond();
    drawarena();
    showplay();
    showstats();
    drawlogo();
    showbuttons();
    showleaderboard();
    showdeck();
};
//}
//shop {
//the shop'S options
var currentoptions = [];
//set as default
for (var ggg = 0; ggg < 7; ggg++) {
    var gag = floor(random(types.length));
    var tim = 0;
    while (types[gag][14] > 0 || types[gag][15] >= 5 || currentoptions.includes(gag)) {
        gag = floor(random(types.length));
        tim++;
        if (tim > 100) {
            break;
        }
    }
    currentoptions.push([gag]);
}
//draws the cards in the shop
var drawcards = function() {
    for (var i = 0; i < currentoptions.length; i++) {

        textAlign(CENTER, CENTER);
        textSize(20);
        fill(0, 180, 255);
        if (mouseX > 150 - 125 & mouseX < 150 + 125 & mouseY > i * 75 + 87.5 - 15 & mouseY < i * 75 + 87.5 + 15) {
            fill(money >= costs[types[currentoptions[i][0]][15]] ? color(0, 120, 255) : color(255, 0, 0));
        }
        stroke(types[currentoptions[i][0]][15] === 3 ? legcolor() : (types[currentoptions[i][0]][15] === 4 ? champcolor() : cardcolors[types[currentoptions[i][0]][15]]));
        strokeWeight(4);
        rect(150, i * 75 + 87.5, 250, 30, 5);
        fill(255, 255, 255);
        text2(types[currentoptions[i][0]][8], 150, i * 75 + 87.5);
        drawmoney(300, i * 75 + 87.5, 25);
        fill(255, 255, 255);
        text2(costs[types[currentoptions[i][0]][15]], 350, i * 75 + 87.5);
        textSize(12);
        text2("DPS: " + (floor(types[currentoptions[i][0]][2] / types[currentoptions[i][0]][3] * 60)) + " HP: " + types[currentoptions[i][0]][0] + " Range: " + types[currentoptions[i][0]][1] + " Speed: " + types[currentoptions[i][0]][5] + " AOE: " + types[currentoptions[i][0]][4] + "\nDescription: " + types[currentoptions[i][0]][16], 150, 75 * i + 125);

    }
};
var refreshcost = function(trophies) {
    return round(pow(3, trophies / 200 + 2) / 10) * 10 * 4;
};
//shows the time until shop refreshes
var updatee = function() {
    fill(0, 180, 255);
    //fix coll
    if (mouseX > 500 - 75 & mouseX < 500 + 75 & mouseY > 162.5 - 25 & mouseY < 162.5 + 25) {
        if (money >= refreshcost(trophies)) {
            fill(0, 120, 255);
        } else {
            fill(255, 0, 0);
        }
    }
    stroke(0, 150, 255);
    strokeWeight(4);
    rect(500, 162.5, 150, 50, 5);
    fill(0, 180, 255);
    rect(500, 100, 150, 50, 5);
    fill(255, 255, 255);
    textSize(17.5);
    text2("Shop updates in\n" + floor(300 - secondee()) + " seconds.", 500, 100);
    text2("Refresh for", 500, 150);
    text2(refreshcost(trophies), 500, 175);
    drawmoney(450, 175, 20);
};
//shows the coins you have
var showcoins = function() {
    drawmoney(437.5, 300, 25);
    fill(255, 255, 255);
    text2("You have", 500, 262.5);
    text2(round(money), 500, 300);
};
//draws the shop title
var drawshoptext = function() {
    textAlign(CENTER, CENTER);
    textSize(37.5);
    fill(255, 255, 255);
    text2("Shop", 300, 37.5);
};
//the shop :)
var shop = function() {
    diamond();
    drawshoptext();
    drawcards();
    updatee();
    drawbackbutton();
    showcoins();
};
//}
//towers and other things {
//Iterates towers
var itertowers = function() {
    //Draws tower
    for (var i = 0; i < towers.length; i++) {
        for (var j = 0; j < towers[i].length; j++) {
            if (towers[i][j][2] > 0) {
                fill(150, 150, 150);
                rect(towers[i][j][0], towers[i][j][1], 50, 50, 5);
                stroke(100, 100, 100);
                strokeWeight(2);
                for (var linee = -15; linee < 25; linee += 10) {
                    line(towers[i][j][0] + linee, towers[i][j][1] - 25, towers[i][j][0] + linee, towers[i][j][1] + 25);
                    line(towers[i][j][0] + 25, towers[i][j][1] + linee, towers[i][j][0] - 25, towers[i][j][1] + linee);
                }
                noStroke();
                fill(i === 1 ? color(0, 200, 255) : color(255, 0, 0));
                rect(towers[i][j][0], towers[i][j][1], 30, 30, 5);
            } else {
                textAlign(CENTER, CENTER);
                textSize(25);
                //text2("(x_x)", towers[i][j][0], towers[i][j][1]);
            }
        }
    }
    //Draws hp
    for (var i = 0; i < towers.length; i++) {
        for (var j = 0; j < towers[i].length; j++) {
            if (towers[i][j][2] > 0) {
                rectMode(CENTER);
                fill(0, 0, 0, 100);
                rect(towers[i][j][0], towers[i][j][1] - 35, 75, 10, 10);
                fill(i === 1 ? color(0, 200, 255) : color(255, 0, 0));
                rect(towers[i][j][0] - (75 - 75 * towers[i][j][2] / towers[i][j][3]) / 2, towers[i][j][1] - 35, 75 * towers[i][j][2] / towers[i][j][3], 10, 10);
                textSize(12.5);
                fill(255, 255, 255);
                text2(round(towers[i][j][2]), towers[i][j][0], towers[i][j][1] - 35);
            }
        }
    }
    //die
    for (var i = 0; i < towers.length; i++) {
        for (var j = 0; j < towers[i].length; j++) {
            towers[i][j][2] = constrain(towers[i][j][2], 0, towers[i][j][3]);
        }
        if (towers[i][0][2] <= 0) {
            init = "Select";
            wl[i] += 1;
            faketrophies += round(random(25, 30)) * (i === 1 ? -1 : 1);
            fakemoney += i !== 1 ? round(pow(3, trophies / 200 + 2) / 10) * 10 * 4 : 0;
            msg = ['You got ' + (i !== 1 ? round(pow(3, trophies / 200 + 2) / 10) * 10 * 4 : 0) + ' coins.', 1];
            bk = 255;
        }
    }
    for (var i = 0; i < towers.length; i++) {
        for (var j = 0; j < towers[i].length; j++) {
            if (towers[i][j][2] <= 0 & c[i] === false) {
                c[i] = true;
                spawntroop(towers[i][0][0], towers[i][0][1], types.length - 1, 1 - i);
            }
        }
    }
};
//ai
var aiselect = function() {
    var pos = [random(0, 600), random(0, 300)];
    /*
    for (var i = 0; i < troops.length; i++) {
        if (troops[i][9] === 0) {
            if (troops[i][6] === 0) {
                for (var j = 0; j < types.length; j++) {
                    if (types[j][8] === "Minion horde") {
                        var r = random(0, 360);
                        var d = random(0, 10);
                        pos.push([j, troops[i][0] + cos(r) * d, troops[i][1] + sin(r) * d]);
                    }
                }
            }
            if (troops[i][19] >= 3) {
                for (var j = 0; j < types.length; j++) {
                    if (types[j][11][1] >= troops[i][15][0] & types[j][4] >= 20 * 1) {
                        var r = random(0, 360);
                        var d = random(0, 10);
                        pos.push([j, troops[i][0] + cos(r) * d, troops[i][1] + sin(r) * d]);
                    }
                }
            }
        }
    }
    */
    if (pos.length >= 1 & false) {
        var choice = floor(random(pos.length));
        nextplacement = [pos[choice][0],
            [pos[choice][1], pos[choice][2]]
        ];
    } else {
        var k = floor(random(types.length));
        /*
        while (types[k][9] <= 2) {
            
            k = floor(random(types.length));
        }
        */
        if (types[k][3] === 0) {
            var selectedtroop = floor(random(0, troops.length));
            var hasselected = false;
            for (var i = selectedtroop; i < troops.length; i++) {
                if (troops[i][9] === 0) {
                    pos = [troops[i][0], troops[i][1]];
                    hasselected = true;
                    break;
                }
            }
            if (!hasselected) {
                for (var i = 0; i < troops.length; i++) {
                    if (troops[i][9] === 0) {
                        pos = [troops[i][0], troops[i][1]];
                        hasselected = true;
                        break;
                    }
                }
            } else {
                var selectedtower = round(random(1, 2));
                pos = [towers[0][selectedtower][0], towers[0][selectedtower][1]];
            }
        }
        nextplacement = [k, pos];

    }
};
var randomnizedeck = function() {
    var newdisplayed = [];
    while (displayed.length > 0) {
        var index = floor(random(displayed.length));
        newdisplayed.push(displayed[index]);
        displayed.splice(index, 1);
    }
    displayed = newdisplayed;
};
//draws the bar and stuff
var drawtop = function() {
    if (from > 0) {
        elixir += 1 / from / 2.2 * (time < 60 ? 2 : 1);
        if (code === 'Dev') {
            elixir = 10;
        }
    }
    //elixir
    elixir = constrain(elixir, 0, 10);
    fill(0, 0, 0, 50);
    rect(575, 300, 25, 505, 5);
    fill(0, 0, 0, 100);
    for (var i = 2; i < 11; i++) {
        rect(575, i * 50, 25, 5, 10);
    }
    fill(255, 0, 255);
    for (var i = 0; i < floor(elixir); i++) {
        rect(575, 600 - i * 50 - 75, 20, 50, 7.5);
    }
    fill(255, 0, 255, 200);
    rect(575, 600 - floor(elixir) * 50 - 75 - ((elixir - floor(elixir)) * 50) / 2 + 25, 20, (elixir - floor(elixir)) * 50, 7.5);
    for (var i = 0; i < displayed.length / 2; i++) {
        fill(0, 180, 255);
        stroke(types[displayed[i]][15] === 3 ? legcolor() : (types[displayed[i]][15] === 4 ? champcolor() : cardcolors[types[displayed[i]][15]]));
        strokeWeight(8);
        rect(55 + (i === selected ? 10 : 0), 300 + i * 75 + 37.5, 100, 65, 5);
        fill(0, 120, 255);
        noStroke();
        rect(55 + (i === selected ? 10 : 0) - (50 - 100 * (constrain(elixir / types[displayed[i]][9], 0, 1)) / 2), 300 + i * 75 + 37.5, 92 * (constrain(elixir / types[displayed[i]][9], 0, 1)), 57);
    }
    noStroke();
    textAlign(CENTER, CENTER);
    for (var i = 0; i < displayed.length / 2; i++) {
        fill(types[displayed[i]][12]);
        ellipse(55 + (i === selected ? 10 : 0), 300 + i * 75 + 37.5, 40, 40);
        fill(types[displayed[i]][13]);
        rect(80 + (i === selected ? 10 : 0), 300 + 75 * i + 37.5, 40 * 2 / 3, 40 / 3, 40 / 4);
        textSize(12);
        textAlign(LEFT, BOTTOM);
        fill(255, 255, 255);
        text2(types[displayed[i]][8], 12.5 + (i === selected ? 10 : 0), 300 + i * 75 + 67.5);
        textAlign(RIGHT, BOTTOM);
        textSize(12);
        text2(types[displayed[i]][9], 82.5 + (i === selected ? 10 : 0), 300 + i * 75 + 67.5);
        drawelixir(90 + (i === selected ? 10 : 0), 300 + i * 75 + 60, 8);
    }
    textAlign(CENTER, CENTER);
    fill(0, 0, 0, 20);
    ellipse(round(mouseX / 20) * 20, round((mouseY - 10) / 20) * 20 + 10, types[displayed[selected]][1] * 2, types[displayed[selected]][1] * 2);
    fill(255, 255, 255, 50);
    if (!mouseside() & types[displayed[selected]][2] === types[displayed[selected]][10] & (types[displayed[selected]][8] !== "Goblin barrel") & (types[displayed[selected]][8] !== "Miner")) {
        fill(255, 0, 0, 200);
    }
    rect(round(mouseX / 20) * 20, round((mouseY - 10) / 20) * 20 + 10, 25, 25);
    rect(round(mouseX / 20) * 20, round((mouseY - 10) / 20) * 20 + 10, 15, 15);
    fill(255, 0, 0, 100);
    if (!mouseside() & types[displayed[selected]][2] === types[displayed[selected]][10] & (types[displayed[selected]][8] !== "Goblin barrel") & (types[displayed[selected]][8] !== "Miner")) {
        rect(300, 100, 600, 200);
        if (towers[0][1][2] > 0) {
            rect(150, 250, 300, 100);
        }
        if (towers[0][2][2] > 0) {
            rect(450, 250, 300, 100);
        }
    }
};
//splashes
var drawsplashes = function() {
    for (var i = 0; i < splashes.length; i++) {
        fill(255, 0, 0, splashes[i][3] / 20 * 255);
        stroke(255, 0, 0);
        strokeWeight(2);
        ellipse(splashes[i][0], splashes[i][1], splashes[i][2], splashes[i][2]);
        splashes[i][3]--;
    }
    for (var i = 0; i < splashes.length; i++) {
        if (splashes[i][3] <= 0) {
            splashes.splice(i, 1);
        }
    }
    noStroke();
};
//blood
var drawblood = function() {
    for (var i = 0; i < blood.length; i++) {
        fill(255, 0, 255, blood[i][3] / 20 * 255);
        ellipse(blood[i][0], blood[i][1], blood[i][2], blood[i][2]);
        blood[i][3]--;
    }
    for (var i = 0; i < blood.length; i++) {
        if (blood[i][3] <= 0) {
            blood.splice(i, 1);
        }
    }
};
//time
var showtime = function() {
    fill(255, 255, 255);
    textSize(30);
    if (time % 60 < 10) {
        text2(floor(time / 60) + ":0" + floor(time % 60), 50, 25);
    } else {
        text2(floor(time / 60) + ":" + floor(time % 60), 50, 25);
    }
    if (from > 0) {
        time -= 1 / from;
    }
    time = constrain(time, 0, 180);
    if (time <= 0) {
        var count = [0, 0];
        for (var i = 0; i < towers.length; i++) {
            for (var j = 0; j < towers[i].length; j++) {
                if (towers[i][j][2] <= 0) {
                    count[i]++;
                }
            }
        }
        if (count[0] > count[1]) {
            init = "Select";
            wl[0] += 1;
            faketrophies += round(random(25, 30));
            fakemoney += round(pow(3, trophies / 200 + 2) / 10) * 10 * count[0];
            msg = ['You got ' + round(pow(3, trophies / 200 + 2) / 10) * 10 * count[0] + ' coins', 1];
            bk = 255;
        } else if (count[0] < count[1]) {
            init = "Select";
            wl[1] += 1;
            faketrophies -= round(random(25, 30));
            msg = ['You got ' + 0 + ' coins', 1];
            fakemoney += 0;
            bk = 255;
        } else {
            for (var i = 0; i < towers.length; i++) {
                for (var j = 0; j < towers[i].length; j++) {
                    towers[i][j][2] -= 10;
                }
            }
        }
    }
    textSize(25);
    drawelixir(520, 30, 15);
    fill(255, 255, 255);
    text2("X" + (time < 60 ? 2 : 1), 550, 25);
};
//emotes
var showemotes = function() {
    if (floor(random(100)) === 0) {
        g = floor(random(emotes.length));
    }
    if (floor(random(100)) === 0) {
        h = floor(random(emotes.length));
    }
    drawbubble(200, 25, 50);
    drawbubble(200, 562.5, 50);
    textAlign(CENTER, CENTER);
    textSize(25);
    fill(0, 0, 0, 200);
    text2(emotes[g], 200, 25);
    text2(yemotes[h], 200, 562.5);
};
//message
var showmessage = function() {
    if (msg[1] > 0) {
        noStroke();
        textAlign(CENTER);
        diamond();
        fill(0, 0, 0);
        rect(230, 387.5, 40, 10);
        rect(370, 387.5, 40, 10);
        fill(255, 220, 12);
        rect(300, 335, 200, 100, 5);
        fill(0, 125, 255);
        rect(300, 350, 180, 50, 10);
        fill(215, 215, 215);
        rect(300, 300, 600, 75);
        colorMode(HSB);
        fill(frameCount % 100 * 255 / 100, 255, msg[1] / 50 * 255);
        pushMatrix();
        translate(300, 300);
        rotate(sin(frameCount * 10) * 4);
        translate(-300, -300);
        textSize(50);
        text2(msg[0], 300, 315);
        popMatrix();
        msg[1]++;
        colorMode(RGB);
        fill(0, 175, 255);
        rect(300, 450, 200, 100, 10);
        fill(255, 220, 12);
        rect(300, 400, 200, 25, 5);
        rect(210, 450, 20, 100, 5);
        rect(390, 450, 20, 100, 5);
        rect(300, 495, 200, 10, 5);
        rect(300, 450, 50, 37.5, 5);
        fill(0, 0, 0);
        ellipse(300, 445, 15, 15);
        triangle(300, 445, 292.5, 465, 307.5, 465);
    }
};
//showing tips
var showtips = function() {
    if (displayed.length <= 0 & !how & !cheese) {
        textSize(20);
        fill(255, 255, 255);
        textAlign(LEFT, TOP);
        //text2("Tip: " + tips[ct], 100, 450, 450, 100);
        //if (frameCount % 50 === 0) {
        //ct = floor(random(tips.length));
        //}
    }
    textAlign(CENTER, CENTER);
};
//self exp.
var showtrophies = function() {
    drawtrophy(375, 10, 25);
    drawtrophy(375, 565, 25);
    fill(255, 255, 255);
    textSize(25);
    text2(etrophies, 425, 20);
    text2(trophies, 425, 580);
};
//}
//how {
//shows the how
var showhow = function() {
    if (how) {
        diamond();
        fill(255, 255, 255);
        textAlign(CENTER, CENTER);
        textSize(50);
        text2("How", 300, 50);
        textAlign(LEFT, TOP);
        textSize(17);
        text2("Game: Select cards in your deck and click to place them. Different cards counter other cards. The key is to use elixir efficiently. To win, you either take down more towers when the game ends, or take down your opponent's King tower.\n\nDeck: To add a card to your deck, click it, and click 'Add to deck'. There are five rarities of cards. Click Upgrade to upgrade your card. Upgrading costs coins.\n\nShop: To unlock a card, you need to buy it in the shop. The shop has 7 cards for you to buy, which refreshes every minute. To buy these cards, you need coins, which you earn from games.\n\nSave: To save your game, click 'Save'. To use it, paste it into the savecode. You can also press 's' in game.\n\nCodes: To get a starting change, type the codes into the 'code' variable.\n\nLeaderboard: There will be no leaderboard. Ever.", 25, 100, 550, 600);
        textAlign(CENTER, CENTER);
        drawbackbutton();
    }
};
//}
//updates stuff that run any time {
//changes the shop and refreshes it
var changeshop = function() {
    if (secondee() >= 299) {
        currentoptions = [];
        for (var ggg = 0; ggg < 7; ggg++) {
            var gag = floor(random(types.length));
            var tim = 0;
            while (types[gag][14] > 0 || types[gag][15] >= 5 || currentoptions.includes(gag)) {
                gag = floor(random(types.length));
                tim++;
                if (tim > 100) {
                    break;
                }
            }
            currentoptions.push([gag]);
        }
    }
};
//shows the fade
var showfade = function() {
    fill(0, 0, 255, bk);
    rect(300, 300, 600, 600);
};
var showselectedy = function() {
    if (selecteed >= 0) {
        stroke(0, 150, 255);
        strokeWeight(4);
        fill(0, 180, 255);
        if (displayed.includes(selecteed)) {
            fill(255, 0, 0);
        }
        if (mouseX > 150 - 75 & mouseX < 150 + 75 & mouseY < 350 + 25 & mouseY > 350 - 25) {
            fill(0, 120, 255);
        }
        rect(150, 350, 150, 50, 10);
        fill(0, 180, 255);
        if (mouseX > 450 - 75 & mouseX < 450 + 75 & mouseY < 350 + 25 & mouseY > 350 - 25) {
            fill(0, 120, 255);
        }
        if (types[selecteed][14] >= 14) {
            fill(255, 0, 0);
        }
        rect(450, 350, 150, 50, 10);
        fill(255, 255, 255);
        textSize(20);
        textAlign(CENTER, CENTER);
        text2(displayed.includes(selecteed) ? 'Remove' : 'Add to deck', 150, 350);
        text2(types[selecteed][14] < 14 ? ('Upgrade\nto Level ' + (types[selecteed][14] + 1)) : "Maxed out", 450, 350);
        if (types[selecteed][14] < 14) {
            drawmoney(500, 390, 20);
        }
        drawmoney(240, 390, 20);
        fill(255, 255, 255);
        if (types[selecteed][14] < 14) {
            if (types[selecteed][15] < 4) {
                text2("Cost: " + upgradeCost[types[selecteed][14] - 1], 425, 390);
            } else {
                text2("Cost: " + upgradeCost[types[selecteed][14] - 1] * 10, 425, 390);
            }
        }
        text2('You have ' + round(money), 150, 390);
    }
};
var showcleardeck = function() {
    stroke(0, 150, 255);
    strokeWeight(4);
    fill(255, 0, 0);
    if (dist(mouseX, mouseY, 550, 450) <= 37.5) {
        fill(0, 120, 255);
    }
    ellipse(550, 450, 75, 75);
    fill(255, 255, 255);
    textSize(20);
    textAlign(CENTER, CENTER);
    text2('Clear\ndeck', 550, 450);
    noStroke();
};
//}
//deck selection main {
var showdecky = function() {
    diamond();
    drawbricks();
    showcards();
    showcardstats();
    drawbackbutton();
    showcleardeck();
    showdeck();
    showselectedy();
};
//}
//pause {
var paused = function() {
    diamond();
    textSize(30);
    fill(0, 0, 0);
    text('The game is paused.\nMove mouse over screen to continue.\nAnyways, feel free to leave feedback!', 297.5, 297.5);
    fill(255, 200, 0);
    text('The game is paused.\nMove mouse over screen to continue.\nAnyways, feel free to leave feedback!', 300, 300);
};
//}
var loadtime = millis();
var initialize = function() {
    getarenaimages();
    diamond();
    drawbricks();
};
initialize();
//println("Loaded in "+(millis()-loadtime) + " milliseconds.");
draw = function() {
    if (ingame === false) {
        pausecounter++;
    } else {
        pausecounter = 0;
    }
    if (pausecounter <= pausetime) {
        from = constrain(this.__frameRate, 10, 60);
        //make transition fade
        bk *= 0.8;
        if (String(key) === "s" & keyIsPressed) {
            var goink = [];
            for (var i = 0; i < types.length; i++) {
                goink.push(types[i][14]);
            }
            println("Copy this:\nvar savecode = [[" + wl[0] + ", " + wl[1] + "], " + money + ", " + trophies + ", [" + goink + "], " + "[" + displayed + "]" + "];");
        }
        //scenes
        if (init === "Game") {
            drawback(arena);
            drawblood();
            itertowers();
            itertroops();
            spawntroops();
            drawtop();
            drawsplashes();
            showtime();
            showemotes();
            showtrophies();
        } else if (init === "Select") {
            troops = [];
            elixir = 5;
            time = 180;
            trophies = constrain(trophies, 0, Infinity);
            select();
            showtips();
            showhow();
            if (msg[1] <= 0) {
                if (trophies !== faketrophies & frameCount % 2 === 0) {
                    trophies += trophies < faketrophies ? 1 : -1;
                }
            }
            realarena = constrain(floor(trophies / 100), 0, arenacolors.length - 1);
        } else if (init === "Shop") {
            shop();
        } else if (init === "Deck") {
            showdecky();
        }
        if (msg[1] <= 0) {
            if (money !== fakemoney & frameCount % 2 === 0) {
                money += round((fakemoney - money) / 2);
            }
        }
        showfade();
        showmessage();
        changeshop();
    } else {
        paused();
    }
    if (keyIsPressed & String(key) === 'f' & code === 'Dev') {
        println('FrameRate: ' + this.__frameRate);
    }
    //cursar();
};
mousePressed = function() {
    if (ingame) {
        pm = mouseX;
        preshift = shiftit;
    }
};
mouseClicked = function() {
    if (pausecounter <= pausetime) {
        if (init === "Game") {
            if (mouseside() || types[displayed[selected]][2] !== types[displayed[selected]][10] || types[displayed[selected]][8] === "Goblin barrel" || types[displayed[selected]][8] === "Miner") {

                if (elixir >= types[displayed[selected]][9] & round(mouseX / 20) * 20 >= 120 & round(mouseX / 20) * 20 <= 480) {
                    spawntroop(round(mouseX / 20) * 20, round((mouseY - 10) / 20) * 20 + 10, displayed[selected], 0);
                    elixir -= types[displayed[selected]][9];
                    displayed.push(displayed[selected]);
                    displayed.splice(selected, 1);
                }
            }
            for (var i = 0; i < displayed.length / 2; i++) {
                if (mouseX > 0 & mouseX < 110 & mouseY > 300 + i * 75 & mouseY < 300 + i * 75 + 75) {
                    selected = i;
                }
            }
        } else if (msg[1] <= 0 & init === "Select" & !how & !cheese) {
            //rect(300, 300, 350, 30, 10); rect(300, 325, 350, 30, 10);
            if (mouseX > 300 - 175 & mouseX < 300 + 175 & mouseY > 325 - 15 & mouseY < 325 + 15) {
                ct = (ct + 1) % tips.length;
            }
            if (mouseX > 250 & mouseX < 350 & mouseY > 355 & mouseY < 405 & displayed.length === 8) {
                randomnizedeck();
                init = "Game";
                bk = 255;
                etrophies = constrain(round(random(trophies - 10, trophies + 10)), 0, Infinity);
                c = [false, false];
                enemyelixir = 5;
                /*
                var towers = [
    [
        [300, 45, 6408, 6408],
        [180, 105, 3668, 3668],
        [420, 105, 3668, 3668],
    ],
    [
        [300, 555, 6408, 6408],
        [180, 495, 3668, 3668],
        [420, 495, 3668, 3668],
    ]
];
                */
                //1 is enemy
                //-4
                spawntroop(180, 105, types.length - 2, 1);
                //-3
                spawntroop(180, 495, types.length - 2, 0);
                //-2
                spawntroop(420, 105, types.length - 2, 1);
                //-1
                spawntroop(420, 495, types.length - 2, 0);
                for (var i = 0; i < towers.length; i++) {
                    for (var j = 0; j < towers[i].length; j++) {
                        if (i === 1) {
                            if (j === 0) {
                                towers[i][j][3] = types[types.length - 1][0] * cardlevelmult[types[types.length - 1][14]];
                            }
                            if (j === 1) {
                                towers[i][j][3] = troops[troops.length - 1][2];
                            }
                            if (j === 2) {
                                towers[i][j][3] = troops[troops.length - 3][2];
                            }
                        }
                        if (i === 0) {
                            if (j === 0) {
                                var garge = constrain((floor(realarena)) + round(random(-2, 4)), 1, 14);
                                etowerlev = garge;
                                towers[i][j][3] = types[types.length - 1][0] * cardlevelmult[garge];
                            }
                            if (j === 2) {
                                towers[i][j][3] = troops[troops.length - 2][2];
                            }
                            if (j === 1) {
                                towers[i][j][3] = troops[troops.length - 4][2];
                            }
                        }
                        towers[i][j][2] = towers[i][j][3];
                    }
                }
            }
            if (dist(mouseX, mouseY, 550, 450) <= 25) {
                var goink = [];
                for (var i = 0; i < types.length; i++) {
                    goink.push(types[i][14]);
                }
                println("Copy this:\nvar savecode = [[" + wl[0] + ", " + wl[1] + "], " + money + ", " + trophies + ", [" + goink + "], " + "[" + displayed + "]" + "];");
            }
            if (dist(mouseX, mouseY, 50, 550) <= 37.5) {
                init = "Shop";
                bk = 255;
            }
            if (dist(mouseX, mouseY, 50, 450) <= 37.5) {
                bk = 255;
                how = true;
            }
            if (dist(mouseX, mouseY, 550, 350) <= 37.5) {
                bk = 255;
                cheese = true;
            }
            if (dist(mouseX, mouseY, 50, 350) <= 37.5) {
                bk = 255;
                init = "Deck";
            }
            if (mouseX > 100 - 50 / 2 & mouseX < 100 + 50 / 2 & mouseY > 175 - 60 & mouseY < 175 + 60) {
                if (arena > 0) {
                    arena -= 1;
                }
            }
            if (mouseX > 500 - 50 / 2 & mouseX < 500 + 50 / 2 & mouseY > 175 - 60 & mouseY < 175 + 60) {
                if (arena < realarena) {
                    arena += 1;
                }
            }
        } else if (msg[1] <= 0 & init === "Select" & how & dist(mouseX, mouseY, 550, 550) <= 37.5) {
            bk = 255;
            how = false;
        } else if (msg[1] <= 0 & init === "Select" & cheese & dist(mouseX, mouseY, 550, 550) <= 37.5) {
            bk = 255;
            cheese = false;
        } else if (init === "Shop" & msg[1] <= 0) {
            if (mouseX > 500 - 75 & mouseX < 500 + 75 & mouseY > 162.5 - 25 & mouseY < 162.5 + 25 & money >= refreshcost(trophies)) {
                fakemoney -= refreshcost(trophies);
                currentoptions = [];
                for (var ggg = 0; ggg < 7; ggg++) {
                    var gag = floor(random(types.length));
                    var tim = 0;
                    while (types[g][14] > 0 || types[g][15] >= 5 || currentoptions.includes(gag)) {
                        gag = floor(random(types.length));
                        tim++;
                        if (tim > 100) {
                            break;
                        }
                    }
                    currentoptions.push([gag]);
                }
            }
            if (dist(mouseX, mouseY, 550, 550) <= 37.5) {
                init = "Select";
                bk = 255;
            }
            for (var i = 0; i < currentoptions.length; i++) {
                if (mouseX > 150 - 125 & mouseX < 150 + 125 & mouseY > i * 75 + 87.5 - 15 & mouseY < i * 75 + 87.5 + 15 & money >= costs[types[currentoptions[i][0]][15]] & secondee() < 299) {

                    types[currentoptions[i][0]][14] = startingLevels[types[currentoptions[i][0]][15]];
                    msg = [types[currentoptions[i][0]][8], 1];
                    bk = 0;
                    fakemoney -= costs[types[currentoptions[i][0]][15]];
                    currentoptions.splice(i, 1);
                }
            }
        } else if (init === "Deck") {
            if (dist(mouseX, mouseY, 550, 550) <= 37.5) {
                init = "Select";
                bk = 255;
            }
            if (dist(mouseX, mouseY, 550, 450) <= 37.5) {
                bk = 255;
                displayed = [];
            }
            for (var i = 0; i < types.length; i++) {
                if (mouseX > floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200 - 47.5 & mouseX < floor(i / 3) * 100 - (shiftit - 300) * 4 - 1200 + 200 + 47.5 & mouseY < i % 3 * 80 + 40 + 37.5 & mouseY > i % 3 * 80 + 40 - 37.5) {
                    if (selecteed === i) {
                        selecteed = -1;
                    } else if (types[i][14] > 0 || code === 'Dev') {
                        selecteed = i;
                        if (code === "Dev") {
                            types[i][14] = 14;
                        }
                    }
                }
            }
            if (mouseX > 150 - 75 & mouseX < 150 + 75 & mouseY < 350 + 25 & mouseY > 350 - 25) {
                if (displayed.includes(selecteed)) {
                    for (var gr = 0; gr < displayed.length; gr++) {
                        if (selecteed === displayed[gr]) {
                            displayed.splice(gr, 1);
                        }
                    }
                } else if (displayed.length < 8) {
                    displayed.push(selecteed);
                }
            }
            if (mouseX > 450 - 75 & mouseX < 450 + 75 & mouseY < 350 + 25 & mouseY > 350 - 25) {
                bk = 255;
                if (types[selecteed][15] < 4) {
                    if (money >= upgradeCost[types[selecteed][14] - 1] & types[selecteed][14] < 14) {
                        fakemoney -= upgradeCost[types[selecteed][14] - 1];
                        types[selecteed][14] += 1;
                    }
                } else {
                    if (money > upgradeCost[types[selecteed][14] - 1] * 10 & types[selecteed][14] < 14) {
                        fakemoney -= upgradeCost[types[selecteed][14] - 1] * 10;
                        types[selecteed][14] += 1;
                    }
                }
            }

        } else if (!how & !cheese) {
            msg[1] = -1;
            bk = 255;
        }
    }
};
mouseOut = function() {
    if (code !== "Dev") {
        ingame = false;
    }
};
mouseOver = function() {
    ingame = true;
};
//}
/////////////////
    }
});
        </script>
    </body>
</html>
